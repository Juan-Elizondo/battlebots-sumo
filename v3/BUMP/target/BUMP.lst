
/home/m/src/auto-sumo/v3/BUMP/target/BUMP.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001998  080a0018  080a0018  00010018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a19b0  00014000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00000008  20000300  080a19b4  00020300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000600  20000308  20000308  00030308  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a19bc  080a19bc  000219bc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a19e4  080a19e4  000219e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   001110fb  00000000  00000000  000219e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00017cea  00000000  00000000  00132ae3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000031f8  00000000  00000000  0014a7cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  000285d5  00000000  00000000  0014d9c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00031189  00000000  00000000  00175f9a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0009bf8a  00000000  00000000  001a7123  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0003d1f6  00000000  00000000  002430ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00006be0  00000000  00000000  002802a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00008b90  00000000  00000000  00286e84  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	bc 16 0a 08                                         ....

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f001 fb29 	bl	80a1684 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f001 fb2e 	bl	80a169a <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a19b4 	.word	0x080a19b4
 80a004c:	20000308 	.word	0x20000308
 80a0050:	20000308 	.word	0x20000308
 80a0054:	20000908 	.word	0x20000908
 80a0058:	20000908 	.word	0x20000908

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f000 ff23 	bl	80a0ea8 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a1940 	.word	0x080a1940
 80a0084:	080a19a8 	.word	0x080a19a8

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 ba48 	b.w	80a051c <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 fa5b 	bl	80a0548 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f000 bec5 	b.w	80a0e24 <_post_loop>

080a009a <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009a:	f000 bc19 	b.w	80a08d0 <free>

080a009e <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a009e:	7800      	ldrb	r0, [r0, #0]
 80a00a0:	fab0 f080 	clz	r0, r0
 80a00a4:	0940      	lsrs	r0, r0, #5
 80a00a6:	4770      	bx	lr

080a00a8 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00a8:	2301      	movs	r3, #1
 80a00aa:	7003      	strb	r3, [r0, #0]
 80a00ac:	4770      	bx	lr

080a00ae <_ZN9LIS3DHI2CD1Ev>:

}

LIS3DHI2C::~LIS3DHI2C() {

}
 80a00ae:	4770      	bx	lr

080a00b0 <_ZN9LIS3DHI2CD0Ev>:

LIS3DHI2C::LIS3DHI2C(TwoWire &wire, uint8_t sad0, int intPin) : LIS3DH(intPin), wire(wire), sad0(sad0) {

}

LIS3DHI2C::~LIS3DHI2C() {
 80a00b0:	b510      	push	{r4, lr}
 80a00b2:	4604      	mov	r4, r0

}
 80a00b4:	f7ff fff1 	bl	80a009a <_ZdlPv>
 80a00b8:	4620      	mov	r0, r4
 80a00ba:	bd10      	pop	{r4, pc}

080a00bc <_ZN9LIS3DHI2C9writeDataEhPKhj>:
		buf[ii] = wire.read();
	}
	return true;
}

bool LIS3DHI2C::writeData(uint8_t addr, const uint8_t *buf, size_t numBytes) {
 80a00bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a00be:	4605      	mov	r5, r0
 80a00c0:	461e      	mov	r6, r3
 80a00c2:	460f      	mov	r7, r1

	return (res == 0);
}

uint8_t LIS3DHI2C::getI2CAddr() const {
	uint8_t addr = (0b0011000 | sad0);
 80a00c4:	7c01      	ldrb	r1, [r0, #16]
	return true;
}

bool LIS3DHI2C::writeData(uint8_t addr, const uint8_t *buf, size_t numBytes) {

	wire.beginTransmission(getI2CAddr());
 80a00c6:	68c0      	ldr	r0, [r0, #12]
 80a00c8:	f041 0118 	orr.w	r1, r1, #24
		buf[ii] = wire.read();
	}
	return true;
}

bool LIS3DHI2C::writeData(uint8_t addr, const uint8_t *buf, size_t numBytes) {
 80a00cc:	4614      	mov	r4, r2

	wire.beginTransmission(getI2CAddr());
 80a00ce:	f000 fccb 	bl	80a0a68 <_ZN7TwoWire17beginTransmissionEh>

	if (numBytes > 1) {
		addr |= I2C_INCREMENT;
	}
	wire.write(addr);
 80a00d2:	68e8      	ldr	r0, [r5, #12]

bool LIS3DHI2C::writeData(uint8_t addr, const uint8_t *buf, size_t numBytes) {

	wire.beginTransmission(getI2CAddr());

	if (numBytes > 1) {
 80a00d4:	2e01      	cmp	r6, #1
		addr |= I2C_INCREMENT;
	}
	wire.write(addr);
 80a00d6:	6803      	ldr	r3, [r0, #0]
bool LIS3DHI2C::writeData(uint8_t addr, const uint8_t *buf, size_t numBytes) {

	wire.beginTransmission(getI2CAddr());

	if (numBytes > 1) {
		addr |= I2C_INCREMENT;
 80a00d8:	bf88      	it	hi
 80a00da:	f047 0780 	orrhi.w	r7, r7, #128	; 0x80
	}
	wire.write(addr);
 80a00de:	689b      	ldr	r3, [r3, #8]
 80a00e0:	4639      	mov	r1, r7
 80a00e2:	4798      	blx	r3
 80a00e4:	4426      	add	r6, r4
	for(size_t ii = 0; ii < numBytes; ii++) {
 80a00e6:	42b4      	cmp	r4, r6
		wire.write(buf[ii]);
 80a00e8:	68e8      	ldr	r0, [r5, #12]

	if (numBytes > 1) {
		addr |= I2C_INCREMENT;
	}
	wire.write(addr);
	for(size_t ii = 0; ii < numBytes; ii++) {
 80a00ea:	d005      	beq.n	80a00f8 <_ZN9LIS3DHI2C9writeDataEhPKhj+0x3c>
		wire.write(buf[ii]);
 80a00ec:	6803      	ldr	r3, [r0, #0]
 80a00ee:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a00f2:	689b      	ldr	r3, [r3, #8]
 80a00f4:	4798      	blx	r3
 80a00f6:	e7f6      	b.n	80a00e6 <_ZN9LIS3DHI2C9writeDataEhPKhj+0x2a>
	}

	uint8_t res = wire.endTransmission();
 80a00f8:	f000 fcbe 	bl	80a0a78 <_ZN7TwoWire15endTransmissionEv>

	return (res == 0);
}
 80a00fc:	fab0 f080 	clz	r0, r0
 80a0100:	0940      	lsrs	r0, r0, #5
 80a0102:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0104 <_ZN9LIS3DHI2C8readDataEhPhj>:

LIS3DHI2C::LIS3DHI2C(uint8_t sad0, int intPin) : LIS3DH(intPin), wire(Wire), sad0(sad0) {

}

bool LIS3DHI2C::readData(uint8_t addr, uint8_t *buf, size_t numBytes) {
 80a0104:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0106:	4604      	mov	r4, r0
 80a0108:	461e      	mov	r6, r3
 80a010a:	460f      	mov	r7, r1

	return (res == 0);
}

uint8_t LIS3DHI2C::getI2CAddr() const {
	uint8_t addr = (0b0011000 | sad0);
 80a010c:	7c01      	ldrb	r1, [r0, #16]
LIS3DHI2C::LIS3DHI2C(uint8_t sad0, int intPin) : LIS3DH(intPin), wire(Wire), sad0(sad0) {

}

bool LIS3DHI2C::readData(uint8_t addr, uint8_t *buf, size_t numBytes) {
	wire.beginTransmission(getI2CAddr());
 80a010e:	68c0      	ldr	r0, [r0, #12]
 80a0110:	f041 0118 	orr.w	r1, r1, #24

LIS3DHI2C::LIS3DHI2C(uint8_t sad0, int intPin) : LIS3DH(intPin), wire(Wire), sad0(sad0) {

}

bool LIS3DHI2C::readData(uint8_t addr, uint8_t *buf, size_t numBytes) {
 80a0114:	4615      	mov	r5, r2
	wire.beginTransmission(getI2CAddr());
 80a0116:	f000 fca7 	bl	80a0a68 <_ZN7TwoWire17beginTransmissionEh>

	if (numBytes > 1) {
		addr |= I2C_INCREMENT;
	}
	wire.write(addr);
 80a011a:	68e0      	ldr	r0, [r4, #12]
}

bool LIS3DHI2C::readData(uint8_t addr, uint8_t *buf, size_t numBytes) {
	wire.beginTransmission(getI2CAddr());

	if (numBytes > 1) {
 80a011c:	2e01      	cmp	r6, #1
		addr |= I2C_INCREMENT;
	}
	wire.write(addr);
 80a011e:	6803      	ldr	r3, [r0, #0]

bool LIS3DHI2C::readData(uint8_t addr, uint8_t *buf, size_t numBytes) {
	wire.beginTransmission(getI2CAddr());

	if (numBytes > 1) {
		addr |= I2C_INCREMENT;
 80a0120:	bf88      	it	hi
 80a0122:	f047 0780 	orrhi.w	r7, r7, #128	; 0x80
	}
	wire.write(addr);
 80a0126:	689b      	ldr	r3, [r3, #8]
 80a0128:	4639      	mov	r1, r7
 80a012a:	4798      	blx	r3

	uint8_t res = wire.endTransmission();
 80a012c:	68e0      	ldr	r0, [r4, #12]
 80a012e:	f000 fca3 	bl	80a0a78 <_ZN7TwoWire15endTransmissionEv>
	if (res != 0) {
 80a0132:	b9a8      	cbnz	r0, 80a0160 <_ZN9LIS3DHI2C8readDataEhPhj+0x5c>

	return (res == 0);
}

uint8_t LIS3DHI2C::getI2CAddr() const {
	uint8_t addr = (0b0011000 | sad0);
 80a0134:	7c21      	ldrb	r1, [r4, #16]
	uint8_t res = wire.endTransmission();
	if (res != 0) {
		return false;
	}

	wire.requestFrom((int)getI2CAddr(), numBytes);
 80a0136:	4632      	mov	r2, r6
 80a0138:	68e0      	ldr	r0, [r4, #12]
 80a013a:	f041 0118 	orr.w	r1, r1, #24
 80a013e:	f000 fc8e 	bl	80a0a5e <_ZN7TwoWire11requestFromEii>
 80a0142:	442e      	add	r6, r5
	for(size_t ii = 0; ii < numBytes && wire.available(); ii++) {
 80a0144:	42b5      	cmp	r5, r6
 80a0146:	d00d      	beq.n	80a0164 <_ZN9LIS3DHI2C8readDataEhPhj+0x60>
 80a0148:	68e0      	ldr	r0, [r4, #12]
 80a014a:	6803      	ldr	r3, [r0, #0]
 80a014c:	691b      	ldr	r3, [r3, #16]
 80a014e:	4798      	blx	r3
 80a0150:	b140      	cbz	r0, 80a0164 <_ZN9LIS3DHI2C8readDataEhPhj+0x60>
		buf[ii] = wire.read();
 80a0152:	68e0      	ldr	r0, [r4, #12]
 80a0154:	6803      	ldr	r3, [r0, #0]
 80a0156:	695b      	ldr	r3, [r3, #20]
 80a0158:	4798      	blx	r3
 80a015a:	f805 0b01 	strb.w	r0, [r5], #1
 80a015e:	e7f1      	b.n	80a0144 <_ZN9LIS3DHI2C8readDataEhPhj+0x40>
	}
	wire.write(addr);

	uint8_t res = wire.endTransmission();
	if (res != 0) {
		return false;
 80a0160:	2000      	movs	r0, #0
 80a0162:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0164:	2001      	movs	r0, #1
	wire.requestFrom((int)getI2CAddr(), numBytes);
	for(size_t ii = 0; ii < numBytes && wire.available(); ii++) {
		buf[ii] = wire.read();
	}
	return true;
}
 80a0166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0168 <_ZN12LIS3DHConfigC1Ev>:
#include "LIS3DH.h"

// Official project location:
// https://github.com/rickkas7/LIS3DH

LIS3DHConfig::LIS3DHConfig() {
 80a0168:	2200      	movs	r2, #0
 80a016a:	7002      	strb	r2, [r0, #0]
 80a016c:	7042      	strb	r2, [r0, #1]
 80a016e:	7082      	strb	r2, [r0, #2]
 80a0170:	70c2      	strb	r2, [r0, #3]
 80a0172:	7102      	strb	r2, [r0, #4]
 80a0174:	7142      	strb	r2, [r0, #5]
 80a0176:	7182      	strb	r2, [r0, #6]
 80a0178:	71c2      	strb	r2, [r0, #7]
 80a017a:	7202      	strb	r2, [r0, #8]
 80a017c:	7242      	strb	r2, [r0, #9]
 80a017e:	7282      	strb	r2, [r0, #10]
}
 80a0180:	4770      	bx	lr

080a0182 <_ZN12LIS3DHConfig12setAccelModeEh>:
}

LIS3DHConfig &LIS3DHConfig::setAccelMode(uint8_t rate) {

	// Enable specified rate, with XYZ detection enabled
	reg1 = rate | LIS3DH::CTRL_REG1_ZEN | LIS3DH::CTRL_REG1_YEN | LIS3DH::CTRL_REG1_XEN;
 80a0182:	f041 0107 	orr.w	r1, r1, #7
 80a0186:	7001      	strb	r1, [r0, #0]

	return *this;
}
 80a0188:	4770      	bx	lr

080a018a <_ZN6LIS3DH13readRegister8Eh>:

	return pos;
}


uint8_t LIS3DH::readRegister8(uint8_t addr) {
 80a018a:	b513      	push	{r0, r1, r4, lr}

	uint8_t resp[1];
	readData(addr, resp, sizeof(resp));
 80a018c:	6803      	ldr	r3, [r0, #0]
 80a018e:	aa01      	add	r2, sp, #4
 80a0190:	689c      	ldr	r4, [r3, #8]
 80a0192:	2301      	movs	r3, #1
 80a0194:	47a0      	blx	r4

	return resp[0];
}
 80a0196:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80a019a:	b002      	add	sp, #8
 80a019c:	bd10      	pop	{r4, pc}

080a019e <_ZN6LIS3DH9hasDeviceEv>:
LIS3DH::~LIS3DH() {

}


bool LIS3DH::hasDevice() {
 80a019e:	b538      	push	{r3, r4, r5, lr}
 80a01a0:	4605      	mov	r5, r0
 80a01a2:	240a      	movs	r4, #10
	bool found = false;
	for(int tries = 0; tries < 10; tries++) {
		uint8_t whoami = readRegister8(REG_WHO_AM_I);
 80a01a4:	4628      	mov	r0, r5
 80a01a6:	210f      	movs	r1, #15
 80a01a8:	f7ff ffef 	bl	80a018a <_ZN6LIS3DH13readRegister8Eh>
		if (whoami == WHO_AM_I) {
 80a01ac:	2833      	cmp	r0, #51	; 0x33
			found = true;
 80a01ae:	f04f 0001 	mov.w	r0, #1

bool LIS3DH::hasDevice() {
	bool found = false;
	for(int tries = 0; tries < 10; tries++) {
		uint8_t whoami = readRegister8(REG_WHO_AM_I);
		if (whoami == WHO_AM_I) {
 80a01b2:	d005      	beq.n	80a01c0 <_ZN6LIS3DH9hasDeviceEv+0x22>
			found = true;
			break;
		}
		delay(1);
 80a01b4:	f000 ff42 	bl	80a103c <delay>
}


bool LIS3DH::hasDevice() {
	bool found = false;
	for(int tries = 0; tries < 10; tries++) {
 80a01b8:	3c01      	subs	r4, #1
 80a01ba:	d1f3      	bne.n	80a01a4 <_ZN6LIS3DH9hasDeviceEv+0x6>

}


bool LIS3DH::hasDevice() {
	bool found = false;
 80a01bc:	4620      	mov	r0, r4
 80a01be:	bd38      	pop	{r3, r4, r5, pc}
			break;
		}
		delay(1);
	}
	return found;
}
 80a01c0:	bd38      	pop	{r3, r4, r5, pc}

080a01c2 <_ZN6LIS3DH9getSampleER12LIS3DHSample>:

	return result;
}


bool LIS3DH::getSample(LIS3DHSample &sample) {
 80a01c2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a01c4:	460c      	mov	r4, r1
	uint8_t statusAuxReg = readRegister8(REG_STATUS_AUX);
 80a01c6:	2107      	movs	r1, #7

	return result;
}


bool LIS3DH::getSample(LIS3DHSample &sample) {
 80a01c8:	4606      	mov	r6, r0
	uint8_t statusAuxReg = readRegister8(REG_STATUS_AUX);
 80a01ca:	f7ff ffde 	bl	80a018a <_ZN6LIS3DH13readRegister8Eh>

	bool hasData = ((statusAuxReg & STATUS_AUX_321DA) != 0);
 80a01ce:	f3c0 05c0 	ubfx	r5, r0, #3, #1

	//Serial.printlnf("fifoSrcReg=0x%02x", fifoSrcReg);

	if (hasData) {
 80a01d2:	b1dd      	cbz	r5, 80a020c <_ZN6LIS3DH9getSampleER12LIS3DHSample+0x4a>
		uint8_t resp[6];
		readData(REG_OUT_X_L, resp, sizeof(resp));
 80a01d4:	6833      	ldr	r3, [r6, #0]
 80a01d6:	466a      	mov	r2, sp
 80a01d8:	689f      	ldr	r7, [r3, #8]
 80a01da:	4630      	mov	r0, r6
 80a01dc:	2306      	movs	r3, #6
 80a01de:	2128      	movs	r1, #40	; 0x28
 80a01e0:	47b8      	blx	r7

		sample.x = (int16_t) (resp[0] | (((uint16_t)resp[1]) << 8));
 80a01e2:	f89d 2001 	ldrb.w	r2, [sp, #1]
 80a01e6:	f89d 3000 	ldrb.w	r3, [sp]
 80a01ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80a01ee:	8023      	strh	r3, [r4, #0]
		sample.y = (int16_t) (resp[2] | (((uint16_t)resp[3]) << 8));
 80a01f0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80a01f4:	f89d 3002 	ldrb.w	r3, [sp, #2]
 80a01f8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80a01fc:	8063      	strh	r3, [r4, #2]
		sample.z = (int16_t) (resp[4] | (((uint16_t)resp[5]) << 8));
 80a01fe:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a0202:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a0206:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80a020a:	80a3      	strh	r3, [r4, #4]
	}
	return hasData;
}
 80a020c:	4628      	mov	r0, r5
 80a020e:	b003      	add	sp, #12
 80a0210:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a0212 <_ZN6LIS3DH14writeRegister8Ehh>:

	return resp[0] | (((uint16_t)resp[1]) << 8);
}


void LIS3DH::writeRegister8(uint8_t addr, uint8_t value) {
 80a0212:	b513      	push	{r0, r1, r4, lr}
	// Serial.printlnf("writeRegister addr=%02x value=%02x", addr, value);

	uint8_t req[1];
	req[0] = value;
 80a0214:	ab02      	add	r3, sp, #8
 80a0216:	f803 2d04 	strb.w	r2, [r3, #-4]!

	writeData(addr, req, sizeof(req));
 80a021a:	6802      	ldr	r2, [r0, #0]
 80a021c:	68d4      	ldr	r4, [r2, #12]
 80a021e:	461a      	mov	r2, r3
 80a0220:	2301      	movs	r3, #1
 80a0222:	47a0      	blx	r4
}
 80a0224:	b002      	add	sp, #8
 80a0226:	bd10      	pop	{r4, pc}

080a0228 <_ZN6LIS3DH5setupER12LIS3DHConfig>:
		delay(1);
	}
	return found;
}

bool LIS3DH::setup(LIS3DHConfig &config) {
 80a0228:	b570      	push	{r4, r5, r6, lr}
 80a022a:	4604      	mov	r4, r0
 80a022c:	460d      	mov	r5, r1

	if (!hasDevice()) {
 80a022e:	f7ff ffb6 	bl	80a019e <_ZN6LIS3DH9hasDeviceEv>
 80a0232:	4606      	mov	r6, r0
 80a0234:	b928      	cbnz	r0, 80a0242 <_ZN6LIS3DH5setupER12LIS3DHConfig+0x1a>
		Serial.println("device not found");
 80a0236:	f000 fd07 	bl	80a0c48 <_Z16_fetch_usbserialv>
 80a023a:	4928      	ldr	r1, [pc, #160]	; (80a02dc <_ZN6LIS3DH5setupER12LIS3DHConfig+0xb4>)
 80a023c:	f000 ff59 	bl	80a10f2 <_ZN5Print7printlnEPKc>
		return false;
 80a0240:	e049      	b.n	80a02d6 <_ZN6LIS3DH5setupER12LIS3DHConfig+0xae>
	}

	writeRegister8(REG_CTRL_REG1, config.reg1);
 80a0242:	4620      	mov	r0, r4
 80a0244:	2120      	movs	r1, #32
 80a0246:	782a      	ldrb	r2, [r5, #0]
 80a0248:	f7ff ffe3 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>
	writeRegister8(REG_CTRL_REG2, config.reg2);
 80a024c:	4620      	mov	r0, r4
 80a024e:	2121      	movs	r1, #33	; 0x21
 80a0250:	786a      	ldrb	r2, [r5, #1]
 80a0252:	f7ff ffde 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>
	writeRegister8(REG_CTRL_REG3, config.reg3);
 80a0256:	4620      	mov	r0, r4
 80a0258:	2122      	movs	r1, #34	; 0x22
 80a025a:	78aa      	ldrb	r2, [r5, #2]
 80a025c:	f7ff ffd9 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>
	writeRegister8(REG_CTRL_REG4, config.reg4);
 80a0260:	4620      	mov	r0, r4
 80a0262:	2123      	movs	r1, #35	; 0x23
 80a0264:	78ea      	ldrb	r2, [r5, #3]
 80a0266:	f7ff ffd4 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>
	writeRegister8(REG_CTRL_REG5, config.reg5);
 80a026a:	4620      	mov	r0, r4
 80a026c:	2124      	movs	r1, #36	; 0x24
 80a026e:	792a      	ldrb	r2, [r5, #4]
 80a0270:	f7ff ffcf 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>
	writeRegister8(REG_CTRL_REG6, config.reg6);
 80a0274:	4620      	mov	r0, r4
 80a0276:	2125      	movs	r1, #37	; 0x25
 80a0278:	796a      	ldrb	r2, [r5, #5]
 80a027a:	f7ff ffca 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>

	if (config.setReference) {
 80a027e:	79ab      	ldrb	r3, [r5, #6]
 80a0280:	b11b      	cbz	r3, 80a028a <_ZN6LIS3DH5setupER12LIS3DHConfig+0x62>
		// In normal mode, reading the reference register sets it for the current normal force
		// (the normal force of gravity acting on the device)
		readRegister8(REG_REFERENCE);
 80a0282:	4620      	mov	r0, r4
 80a0284:	2126      	movs	r1, #38	; 0x26
 80a0286:	f7ff ff80 	bl	80a018a <_ZN6LIS3DH13readRegister8Eh>
	}
	// Set FIFO mode
	writeRegister8(REG_FIFO_CTRL_REG, config.fifoCtrlReg);
 80a028a:	4620      	mov	r0, r4
 80a028c:	212e      	movs	r1, #46	; 0x2e
 80a028e:	7aaa      	ldrb	r2, [r5, #10]
 80a0290:	f7ff ffbf 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>



	if ((config.reg3 & CTRL_REG3_I1_INT1) != 0) {
 80a0294:	78ab      	ldrb	r3, [r5, #2]
 80a0296:	065b      	lsls	r3, r3, #25
 80a0298:	d51d      	bpl.n	80a02d6 <_ZN6LIS3DH5setupER12LIS3DHConfig+0xae>

		writeRegister8(REG_INT1_THS, config.int1_ths);
 80a029a:	4620      	mov	r0, r4
 80a029c:	2132      	movs	r1, #50	; 0x32
 80a029e:	79ea      	ldrb	r2, [r5, #7]
 80a02a0:	f7ff ffb7 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>
		writeRegister8(REG_INT1_DURATION, config.int1_duration);
 80a02a4:	4620      	mov	r0, r4
 80a02a6:	2133      	movs	r1, #51	; 0x33
 80a02a8:	7a2a      	ldrb	r2, [r5, #8]
 80a02aa:	f7ff ffb2 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>

		if (intPin >= 0) {
 80a02ae:	6863      	ldr	r3, [r4, #4]
 80a02b0:	2b00      	cmp	r3, #0
 80a02b2:	db0a      	blt.n	80a02ca <_ZN6LIS3DH5setupER12LIS3DHConfig+0xa2>
			// as I can tell this never works. Merely setting the INT1_CFG does not ever generate an
			// interrupt for me.

			// Remember the INT1_CFG setting because we're apparently supposed to set it again after
			// clearing an interrupt.
			int1_cfg = config.int1_cfg;
 80a02b4:	7a6a      	ldrb	r2, [r5, #9]
			writeRegister8(REG_INT1_CFG, int1_cfg);
 80a02b6:	4620      	mov	r0, r4
			// as I can tell this never works. Merely setting the INT1_CFG does not ever generate an
			// interrupt for me.

			// Remember the INT1_CFG setting because we're apparently supposed to set it again after
			// clearing an interrupt.
			int1_cfg = config.int1_cfg;
 80a02b8:	7222      	strb	r2, [r4, #8]
			writeRegister8(REG_INT1_CFG, int1_cfg);
 80a02ba:	2130      	movs	r1, #48	; 0x30
 80a02bc:	f7ff ffa9 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>

			// Clear the interrupt just in case
			readRegister8(REG_INT1_SRC);
 80a02c0:	4620      	mov	r0, r4
 80a02c2:	2131      	movs	r1, #49	; 0x31
 80a02c4:	f7ff ff61 	bl	80a018a <_ZN6LIS3DH13readRegister8Eh>
 80a02c8:	e005      	b.n	80a02d6 <_ZN6LIS3DH5setupER12LIS3DHConfig+0xae>
		}
		else {
			int1_cfg = 0;
 80a02ca:	2200      	movs	r2, #0
 80a02cc:	7222      	strb	r2, [r4, #8]
			writeRegister8(REG_INT1_CFG, 0);
 80a02ce:	4620      	mov	r0, r4
 80a02d0:	2130      	movs	r1, #48	; 0x30
 80a02d2:	f7ff ff9e 	bl	80a0212 <_ZN6LIS3DH14writeRegister8Ehh>




	return true;
}
 80a02d6:	4630      	mov	r0, r6
 80a02d8:	bd70      	pop	{r4, r5, r6, pc}
 80a02da:	bf00      	nop
 80a02dc:	080a16e8 	.word	0x080a16e8

080a02e0 <_ZN9LIS3DHI2CC1ER7TwoWirehi>:

//
//
//

LIS3DHI2C::LIS3DHI2C(TwoWire &wire, uint8_t sad0, int intPin) : LIS3DH(intPin), wire(wire), sad0(sad0) {
 80a02e0:	b510      	push	{r4, lr}

	return *this;
}


LIS3DH::LIS3DH(int intPin) : intPin(intPin) {
 80a02e2:	6043      	str	r3, [r0, #4]

//
//
//

LIS3DHI2C::LIS3DHI2C(TwoWire &wire, uint8_t sad0, int intPin) : LIS3DH(intPin), wire(wire), sad0(sad0) {
 80a02e4:	4b02      	ldr	r3, [pc, #8]	; (80a02f0 <_ZN9LIS3DHI2CC1ER7TwoWirehi+0x10>)
 80a02e6:	60c1      	str	r1, [r0, #12]
 80a02e8:	6003      	str	r3, [r0, #0]
 80a02ea:	7402      	strb	r2, [r0, #16]

}
 80a02ec:	bd10      	pop	{r4, pc}
 80a02ee:	bf00      	nop
 80a02f0:	080a16d8 	.word	0x080a16d8

080a02f4 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev>:

uint8_t LIS3DHI2C::getI2CAddr() const {
	uint8_t addr = (0b0011000 | sad0);

	return addr;
}
 80a02f4:	b508      	push	{r3, lr}
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a02f6:	4b0a      	ldr	r3, [pc, #40]	; (80a0320 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x2c>)
 80a02f8:	2200      	movs	r2, #0
 80a02fa:	490a      	ldr	r1, [pc, #40]	; (80a0324 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x30>)
 80a02fc:	701a      	strb	r2, [r3, #0]
 80a02fe:	2301      	movs	r3, #1
 80a0300:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a0302:	4909      	ldr	r1, [pc, #36]	; (80a0328 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x34>)
 80a0304:	700a      	strb	r2, [r1, #0]
 80a0306:	4a09      	ldr	r2, [pc, #36]	; (80a032c <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x38>)
 80a0308:	7013      	strb	r3, [r2, #0]
 80a030a:	4b09      	ldr	r3, [pc, #36]	; (80a0330 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x3c>)
 80a030c:	2202      	movs	r2, #2
 80a030e:	701a      	strb	r2, [r3, #0]
 80a0310:	4b08      	ldr	r3, [pc, #32]	; (80a0334 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x40>)
 80a0312:	2208      	movs	r2, #8
 80a0314:	701a      	strb	r2, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a0316:	f000 faa3 	bl	80a0860 <HAL_Pin_Map>
 80a031a:	4b07      	ldr	r3, [pc, #28]	; (80a0338 <_GLOBAL__sub_I__ZN12LIS3DHConfigC2Ev+0x44>)
 80a031c:	6018      	str	r0, [r3, #0]
 80a031e:	bd08      	pop	{r3, pc}
 80a0320:	20000313 	.word	0x20000313
 80a0324:	20000315 	.word	0x20000315
 80a0328:	20000311 	.word	0x20000311
 80a032c:	20000312 	.word	0x20000312
 80a0330:	20000310 	.word	0x20000310
 80a0334:	20000314 	.word	0x20000314
 80a0338:	2000030c 	.word	0x2000030c

080a033c <_GLOBAL__sub_I__ZN7VL53L0XC2Ev>:
  writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);

  writeReg(SYSRANGE_START, 0x00);

  return true;
}
 80a033c:	b508      	push	{r3, lr}
 80a033e:	4b0a      	ldr	r3, [pc, #40]	; (80a0368 <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x2c>)
 80a0340:	2200      	movs	r2, #0
 80a0342:	490a      	ldr	r1, [pc, #40]	; (80a036c <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x30>)
 80a0344:	701a      	strb	r2, [r3, #0]
 80a0346:	2301      	movs	r3, #1
 80a0348:	700b      	strb	r3, [r1, #0]
 80a034a:	4909      	ldr	r1, [pc, #36]	; (80a0370 <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x34>)
 80a034c:	700a      	strb	r2, [r1, #0]
 80a034e:	4a09      	ldr	r2, [pc, #36]	; (80a0374 <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x38>)
 80a0350:	7013      	strb	r3, [r2, #0]
 80a0352:	4b09      	ldr	r3, [pc, #36]	; (80a0378 <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x3c>)
 80a0354:	2202      	movs	r2, #2
 80a0356:	701a      	strb	r2, [r3, #0]
 80a0358:	4b08      	ldr	r3, [pc, #32]	; (80a037c <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x40>)
 80a035a:	2208      	movs	r2, #8
 80a035c:	701a      	strb	r2, [r3, #0]
 80a035e:	f000 fa7f 	bl	80a0860 <HAL_Pin_Map>
 80a0362:	4b07      	ldr	r3, [pc, #28]	; (80a0380 <_GLOBAL__sub_I__ZN7VL53L0XC2Ev+0x44>)
 80a0364:	6018      	str	r0, [r3, #0]
 80a0366:	bd08      	pop	{r3, pc}
 80a0368:	2000031a 	.word	0x2000031a
 80a036c:	20000320 	.word	0x20000320
 80a0370:	20000318 	.word	0x20000318
 80a0374:	20000319 	.word	0x20000319
 80a0378:	20000317 	.word	0x20000317
 80a037c:	20000316 	.word	0x20000316
 80a0380:	2000031c 	.word	0x2000031c

080a0384 <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
	(*_Base::_M_get_pointer(__functor))(
 80a0384:	6803      	ldr	r3, [r0, #0]
 80a0386:	4718      	bx	r3

080a0388 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a0388:	2a01      	cmp	r2, #1
 80a038a:	d002      	beq.n	80a0392 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xa>
 80a038c:	2a02      	cmp	r2, #2
 80a038e:	d002      	beq.n	80a0396 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xe>
 80a0390:	e004      	b.n	80a039c <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a0392:	6001      	str	r1, [r0, #0]
	      break;
 80a0394:	e002      	b.n	80a039c <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	// Clone a location-invariant function object that fits within
	// an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
	{
	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a0396:	680b      	ldr	r3, [r1, #0]
 80a0398:	b100      	cbz	r0, 80a039c <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
 80a039a:	6003      	str	r3, [r0, #0]
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a039c:	2000      	movs	r0, #0
 80a039e:	4770      	bx	lr

080a03a0 <_Z8getAccelv>:
Timer timer(100, getAccel);
const unsigned long PRINT_SAMPLE_PERIOD = 100;
LIS3DHI2C accel(Wire, 0, WKP);
unsigned long lastPrintSample = 0;

void getAccel() {
 80a03a0:	b510      	push	{r4, lr}
  accel.getSample(sample);
 80a03a2:	4c05      	ldr	r4, [pc, #20]	; (80a03b8 <_Z8getAccelv+0x18>)
 80a03a4:	4805      	ldr	r0, [pc, #20]	; (80a03bc <_Z8getAccelv+0x1c>)
 80a03a6:	4621      	mov	r1, r4
 80a03a8:	f7ff ff0b 	bl	80a01c2 <_ZN6LIS3DH9getSampleER12LIS3DHSample>
  curAccel = sample.x;
 80a03ac:	f9b4 2000 	ldrsh.w	r2, [r4]
 80a03b0:	4b03      	ldr	r3, [pc, #12]	; (80a03c0 <_Z8getAccelv+0x20>)
 80a03b2:	601a      	str	r2, [r3, #0]
 80a03b4:	bd10      	pop	{r4, pc}
 80a03b6:	bf00      	nop
 80a03b8:	2000032a 	.word	0x2000032a
 80a03bc:	20000334 	.word	0x20000334
 80a03c0:	20000368 	.word	0x20000368

080a03c4 <_ZN5Timer7timeoutEv>:

    /*
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
 80a03c4:	b510      	push	{r4, lr}
    {
		running = true;
 80a03c6:	2301      	movs	r3, #1
 80a03c8:	7103      	strb	r3, [r0, #4]
        if (callback)
 80a03ca:	6943      	ldr	r3, [r0, #20]

    /*
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
 80a03cc:	4604      	mov	r4, r0
    {
		running = true;
        if (callback)
 80a03ce:	b113      	cbz	r3, 80a03d6 <_ZN5Timer7timeoutEv+0x12>
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a03d0:	6983      	ldr	r3, [r0, #24]
 80a03d2:	300c      	adds	r0, #12
 80a03d4:	4798      	blx	r3
        {
            callback();
        }
        running = false;
 80a03d6:	2300      	movs	r3, #0
 80a03d8:	7123      	strb	r3, [r4, #4]
 80a03da:	bd10      	pop	{r4, pc}

080a03dc <_ZN5Timer12invoke_timerEPv>:
private:
	volatile bool running;
    os_timer_t handle;
    timer_callback_fn callback;

    static void invoke_timer(os_timer_t timer)
 80a03dc:	b507      	push	{r0, r1, r2, lr}
    {
        void* timer_id = NULL;
 80a03de:	2300      	movs	r3, #0
 80a03e0:	a902      	add	r1, sp, #8
 80a03e2:	f841 3d04 	str.w	r3, [r1, #-4]!
        if (!os_timer_get_id(timer, &timer_id)) {
 80a03e6:	f000 fa03 	bl	80a07f0 <os_timer_get_id>
 80a03ea:	b920      	cbnz	r0, 80a03f6 <_ZN5Timer12invoke_timerEPv+0x1a>
            if (timer_id)
 80a03ec:	9801      	ldr	r0, [sp, #4]
 80a03ee:	b110      	cbz	r0, 80a03f6 <_ZN5Timer12invoke_timerEPv+0x1a>
                ((Timer*)timer_id)->timeout();
 80a03f0:	6803      	ldr	r3, [r0, #0]
 80a03f2:	689b      	ldr	r3, [r3, #8]
 80a03f4:	4798      	blx	r3
        }
    }
 80a03f6:	b003      	add	sp, #12
 80a03f8:	f85d fb04 	ldr.w	pc, [sp], #4

080a03fc <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
 80a03fc:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a03fe:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
 80a0400:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a0402:	b113      	cbz	r3, 80a040a <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0404:	4601      	mov	r1, r0
 80a0406:	2203      	movs	r2, #3
 80a0408:	4798      	blx	r3
    }
 80a040a:	4620      	mov	r0, r4
 80a040c:	bd10      	pop	{r4, pc}
	...

080a0410 <_ZN5TimerD1Ev>:
    template <typename T>
    Timer(unsigned period, void (T::*handler)(), T& instance, bool one_shot=false) : Timer(period, std::bind(handler, &instance), one_shot)
    {
    }

    virtual ~Timer() {
 80a0410:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0412:	4b11      	ldr	r3, [pc, #68]	; (80a0458 <_ZN5TimerD1Ev+0x48>)
 80a0414:	4604      	mov	r4, r0
 80a0416:	6003      	str	r3, [r0, #0]
         return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_PERIOD, fromISR, period, block, nullptr) : false;
    }

    void dispose()
    {
        if (handle)
 80a0418:	6880      	ldr	r0, [r0, #8]
 80a041a:	b1a8      	cbz	r0, 80a0448 <_ZN5TimerD1Ev+0x38>
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
    }

    bool _stop(unsigned block, bool fromISR=false)
    {
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_STOP, fromISR, 0, block, nullptr) : false;
 80a041c:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 80a0420:	2200      	movs	r2, #0
 80a0422:	9300      	str	r3, [sp, #0]
 80a0424:	9201      	str	r2, [sp, #4]
 80a0426:	2102      	movs	r1, #2
 80a0428:	4613      	mov	r3, r2
 80a042a:	f000 f9e9 	bl	80a0800 <os_timer_change>
    void dispose()
    {
        if (handle)
        	{
        		stop();
        		while (running) {
 80a042e:	7923      	ldrb	r3, [r4, #4]
 80a0430:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80a0434:	b11b      	cbz	r3, 80a043e <_ZN5TimerD1Ev+0x2e>
				delay(1);
 80a0436:	2001      	movs	r0, #1
 80a0438:	f000 fe00 	bl	80a103c <delay>
 80a043c:	e7f7      	b.n	80a042e <_ZN5TimerD1Ev+0x1e>
			}
        		os_timer_destroy(handle, nullptr);
 80a043e:	68a0      	ldr	r0, [r4, #8]
 80a0440:	4629      	mov	r1, r5
 80a0442:	f000 f9cd 	bl	80a07e0 <os_timer_destroy>
            handle = nullptr;
 80a0446:	60a5      	str	r5, [r4, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0448:	f104 000c 	add.w	r0, r4, #12
 80a044c:	f7ff ffd6 	bl	80a03fc <_ZNSt14_Function_baseD1Ev>

    virtual ~Timer() {
    		// when the timer is calling the std::function, we cannot dispose of it until the function completes.
		// the call has exited.
		dispose();
    }
 80a0450:	4620      	mov	r0, r4
 80a0452:	b003      	add	sp, #12
 80a0454:	bd30      	pop	{r4, r5, pc}
 80a0456:	bf00      	nop
 80a0458:	080a1738 	.word	0x080a1738

080a045c <_ZN5TimerD0Ev>:
    template <typename T>
    Timer(unsigned period, void (T::*handler)(), T& instance, bool one_shot=false) : Timer(period, std::bind(handler, &instance), one_shot)
    {
    }

    virtual ~Timer() {
 80a045c:	b510      	push	{r4, lr}
 80a045e:	4604      	mov	r4, r0
    		// when the timer is calling the std::function, we cannot dispose of it until the function completes.
		// the call has exited.
		dispose();
    }
 80a0460:	f7ff ffd6 	bl	80a0410 <_ZN5TimerD1Ev>
 80a0464:	4620      	mov	r0, r4
 80a0466:	f7ff fe18 	bl	80a009a <_ZdlPv>
 80a046a:	4620      	mov	r0, r4
 80a046c:	bd10      	pop	{r4, pc}
	...

080a0470 <_Z10accel_initv>:


// Accelerometer


void accel_init() {
 80a0470:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	LIS3DHConfig config;
 80a0472:	a801      	add	r0, sp, #4
 80a0474:	f7ff fe78 	bl	80a0168 <_ZN12LIS3DHConfigC1Ev>
	config.setAccelMode(LIS3DH::RATE_400_HZ);
 80a0478:	a801      	add	r0, sp, #4
 80a047a:	2170      	movs	r1, #112	; 0x70
 80a047c:	f7ff fe81 	bl	80a0182 <_ZN12LIS3DHConfig12setAccelModeEh>

	bool setupSuccess = accel.setup(config);
 80a0480:	a901      	add	r1, sp, #4
 80a0482:	4806      	ldr	r0, [pc, #24]	; (80a049c <_Z10accel_initv+0x2c>)
 80a0484:	f7ff fed0 	bl	80a0228 <_ZN6LIS3DH5setupER12LIS3DHConfig>
 80a0488:	4604      	mov	r4, r0
	Serial.printlnf("setupSuccess=%d", setupSuccess);
 80a048a:	f000 fbdd 	bl	80a0c48 <_Z16_fetch_usbserialv>
    }

    template <typename... Args>
    inline size_t printlnf(const char* format, Args... args)
    {
        return this->printf_impl(true, format, args...);
 80a048e:	2101      	movs	r1, #1
 80a0490:	4a03      	ldr	r2, [pc, #12]	; (80a04a0 <_Z10accel_initv+0x30>)
 80a0492:	4623      	mov	r3, r4
 80a0494:	f000 fe65 	bl	80a1162 <_ZN5Print11printf_implEbPKcz>
}
 80a0498:	b004      	add	sp, #16
 80a049a:	bd10      	pop	{r4, pc}
 80a049c:	20000334 	.word	0x20000334
 80a04a0:	080a1744 	.word	0x080a1744

080a04a4 <_Z13runDiagnosticv>:


void runDiagnostic() {
 80a04a4:	b513      	push	{r0, r1, r4, lr}
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a04a6:	f000 f9c3 	bl	80a0830 <HAL_Timer_Get_Milli_Seconds>
  
  
  if (millis() - lastPrintSample >= PRINT_SAMPLE_PERIOD) {
 80a04aa:	4c16      	ldr	r4, [pc, #88]	; (80a0504 <_Z13runDiagnosticv+0x60>)
 80a04ac:	6823      	ldr	r3, [r4, #0]
 80a04ae:	1ac0      	subs	r0, r0, r3
 80a04b0:	2863      	cmp	r0, #99	; 0x63
 80a04b2:	d924      	bls.n	80a04fe <_Z13runDiagnosticv+0x5a>
 80a04b4:	f000 f9bc 	bl	80a0830 <HAL_Timer_Get_Milli_Seconds>
		lastPrintSample = millis();
 80a04b8:	6020      	str	r0, [r4, #0]
    Serial.print("Accel values: ");
		if (accel.getSample(sample)) {
 80a04ba:	4c13      	ldr	r4, [pc, #76]	; (80a0508 <_Z13runDiagnosticv+0x64>)
void runDiagnostic() {
  
  
  if (millis() - lastPrintSample >= PRINT_SAMPLE_PERIOD) {
		lastPrintSample = millis();
    Serial.print("Accel values: ");
 80a04bc:	f000 fbc4 	bl	80a0c48 <_Z16_fetch_usbserialv>
 80a04c0:	4912      	ldr	r1, [pc, #72]	; (80a050c <_Z13runDiagnosticv+0x68>)
 80a04c2:	f000 fe03 	bl	80a10cc <_ZN5Print5printEPKc>
		if (accel.getSample(sample)) {
 80a04c6:	4812      	ldr	r0, [pc, #72]	; (80a0510 <_Z13runDiagnosticv+0x6c>)
 80a04c8:	4621      	mov	r1, r4
 80a04ca:	f7ff fe7a 	bl	80a01c2 <_ZN6LIS3DH9getSampleER12LIS3DHSample>
 80a04ce:	b170      	cbz	r0, 80a04ee <_Z13runDiagnosticv+0x4a>
			Serial.printlnf("%d,%d,%d", sample.x, sample.y, sample.z);
 80a04d0:	f000 fbba 	bl	80a0c48 <_Z16_fetch_usbserialv>
 80a04d4:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 80a04d8:	f9b4 3000 	ldrsh.w	r3, [r4]
 80a04dc:	9200      	str	r2, [sp, #0]
 80a04de:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
 80a04e2:	2101      	movs	r1, #1
 80a04e4:	9201      	str	r2, [sp, #4]
 80a04e6:	4a0b      	ldr	r2, [pc, #44]	; (80a0514 <_Z13runDiagnosticv+0x70>)
 80a04e8:	f000 fe3b 	bl	80a1162 <_ZN5Print11printf_implEbPKcz>
 80a04ec:	e007      	b.n	80a04fe <_Z13runDiagnosticv+0x5a>
		}
		else {
			Serial.println("no sample");
 80a04ee:	f000 fbab 	bl	80a0c48 <_Z16_fetch_usbserialv>
 80a04f2:	4909      	ldr	r1, [pc, #36]	; (80a0518 <_Z13runDiagnosticv+0x74>)
		}
	}
}
 80a04f4:	b002      	add	sp, #8
 80a04f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    Serial.print("Accel values: ");
		if (accel.getSample(sample)) {
			Serial.printlnf("%d,%d,%d", sample.x, sample.y, sample.z);
		}
		else {
			Serial.println("no sample");
 80a04fa:	f000 bdfa 	b.w	80a10f2 <_ZN5Print7printlnEPKc>
		}
	}
}
 80a04fe:	b002      	add	sp, #8
 80a0500:	bd10      	pop	{r4, pc}
 80a0502:	bf00      	nop
 80a0504:	20000324 	.word	0x20000324
 80a0508:	2000032a 	.word	0x2000032a
 80a050c:	080a1754 	.word	0x080a1754
 80a0510:	20000334 	.word	0x20000334
 80a0514:	080a1763 	.word	0x080a1763
 80a0518:	080a176c 	.word	0x080a176c

080a051c <setup>:



void setup()
{
 80a051c:	b508      	push	{r3, lr}
  pinMode(accelPin, INPUT);
 80a051e:	4b09      	ldr	r3, [pc, #36]	; (80a0544 <setup+0x28>)
 80a0520:	2100      	movs	r1, #0
 80a0522:	8818      	ldrh	r0, [r3, #0]
 80a0524:	f000 ffa6 	bl	80a1474 <pinMode>
  Serial.begin(9600);
 80a0528:	f000 fb8e 	bl	80a0c48 <_Z16_fetch_usbserialv>
 80a052c:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0530:	f000 fb70 	bl	80a0c14 <_ZN9USBSerial5beginEl>

  accel_init();
 80a0534:	f7ff ff9c 	bl	80a0470 <_Z10accel_initv>
  //timer.start();
  delay(1000);
}
 80a0538:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  pinMode(accelPin, INPUT);
  Serial.begin(9600);

  accel_init();
  //timer.start();
  delay(1000);
 80a053c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0540:	f000 bd7c 	b.w	80a103c <delay>
 80a0544:	20000300 	.word	0x20000300

080a0548 <loop>:
}

void loop()
{
  runDiagnostic();
 80a0548:	f7ff bfac 	b.w	80a04a4 <_Z13runDiagnosticv>

080a054c <_GLOBAL__sub_I_accelPin>:
 80a054c:	4b2a      	ldr	r3, [pc, #168]	; (80a05f8 <_GLOBAL__sub_I_accelPin+0xac>)
 
}
 80a054e:	b570      	push	{r4, r5, r6, lr}
 80a0550:	4a2a      	ldr	r2, [pc, #168]	; (80a05fc <_GLOBAL__sub_I_accelPin+0xb0>)
 80a0552:	2500      	movs	r5, #0
 80a0554:	701d      	strb	r5, [r3, #0]
 80a0556:	2301      	movs	r3, #1
 80a0558:	7013      	strb	r3, [r2, #0]
 80a055a:	4a29      	ldr	r2, [pc, #164]	; (80a0600 <_GLOBAL__sub_I_accelPin+0xb4>)
 80a055c:	b088      	sub	sp, #32
 80a055e:	7015      	strb	r5, [r2, #0]
 80a0560:	4a28      	ldr	r2, [pc, #160]	; (80a0604 <_GLOBAL__sub_I_accelPin+0xb8>)
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0562:	ae04      	add	r6, sp, #16
 80a0564:	7013      	strb	r3, [r2, #0]
 80a0566:	4b28      	ldr	r3, [pc, #160]	; (80a0608 <_GLOBAL__sub_I_accelPin+0xbc>)
 80a0568:	2202      	movs	r2, #2
 80a056a:	701a      	strb	r2, [r3, #0]
 80a056c:	4b27      	ldr	r3, [pc, #156]	; (80a060c <_GLOBAL__sub_I_accelPin+0xc0>)
 80a056e:	2208      	movs	r2, #8
 80a0570:	701a      	strb	r2, [r3, #0]
 80a0572:	f000 f975 	bl	80a0860 <HAL_Pin_Map>
 80a0576:	4b26      	ldr	r3, [pc, #152]	; (80a0610 <_GLOBAL__sub_I_accelPin+0xc4>)
 80a0578:	aa02      	add	r2, sp, #8
 80a057a:	6018      	str	r0, [r3, #0]
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a057c:	4b25      	ldr	r3, [pc, #148]	; (80a0614 <_GLOBAL__sub_I_accelPin+0xc8>)
{
public:

    typedef std::function<void(void)> timer_callback_fn;

    Timer(unsigned period, timer_callback_fn callback_, bool one_shot=false) : running(false), handle(nullptr), callback(std::move(callback_)) {
 80a057e:	4c26      	ldr	r4, [pc, #152]	; (80a0618 <_GLOBAL__sub_I_accelPin+0xcc>)
 80a0580:	9304      	str	r3, [sp, #16]
 80a0582:	e896 0003 	ldmia.w	r6, {r0, r1}
 80a0586:	4b25      	ldr	r3, [pc, #148]	; (80a061c <_GLOBAL__sub_I_accelPin+0xd0>)
 80a0588:	e882 0003 	stmia.w	r2, {r0, r1}
 80a058c:	6023      	str	r3, [r4, #0]
      __a = _GLIBCXX_MOVE(__b);
 80a058e:	f104 030c 	add.w	r3, r4, #12
 80a0592:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a0596:	e886 0003 	stmia.w	r6, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a059a:	e892 0003 	ldmia.w	r2, {r0, r1}
 80a059e:	e883 0003 	stmia.w	r3, {r0, r1}
 80a05a2:	4b1f      	ldr	r3, [pc, #124]	; (80a0620 <_GLOBAL__sub_I_accelPin+0xd4>)
 80a05a4:	7125      	strb	r5, [r4, #4]
 80a05a6:	6163      	str	r3, [r4, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a05a8:	69a3      	ldr	r3, [r4, #24]
 80a05aa:	60a5      	str	r5, [r4, #8]
 80a05ac:	9307      	str	r3, [sp, #28]
      __b = _GLIBCXX_MOVE(__tmp);
 80a05ae:	4b1d      	ldr	r3, [pc, #116]	; (80a0624 <_GLOBAL__sub_I_accelPin+0xd8>)
        os_timer_create(&handle, period, invoke_timer, this, one_shot, nullptr);
 80a05b0:	2164      	movs	r1, #100	; 0x64
 80a05b2:	61a3      	str	r3, [r4, #24]
 80a05b4:	4a1c      	ldr	r2, [pc, #112]	; (80a0628 <_GLOBAL__sub_I_accelPin+0xdc>)
 80a05b6:	4623      	mov	r3, r4
 80a05b8:	9500      	str	r5, [sp, #0]
 80a05ba:	9501      	str	r5, [sp, #4]
 80a05bc:	f104 0008 	add.w	r0, r4, #8
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a05c0:	9506      	str	r5, [sp, #24]
 80a05c2:	f000 f905 	bl	80a07d0 <os_timer_create>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a05c6:	4630      	mov	r0, r6
*/
void getAccel();
int accelPin = D1;
int curAccel = 0;
LIS3DHSample sample;
Timer timer(100, getAccel);
 80a05c8:	4e18      	ldr	r6, [pc, #96]	; (80a062c <_GLOBAL__sub_I_accelPin+0xe0>)
 80a05ca:	f7ff ff17 	bl	80a03fc <_ZNSt14_Function_baseD1Ev>
 80a05ce:	4632      	mov	r2, r6
 80a05d0:	4917      	ldr	r1, [pc, #92]	; (80a0630 <_GLOBAL__sub_I_accelPin+0xe4>)
 80a05d2:	4620      	mov	r0, r4
 80a05d4:	f000 ff7e 	bl	80a14d4 <__aeabi_atexit>
const unsigned long PRINT_SAMPLE_PERIOD = 100;
LIS3DHI2C accel(Wire, 0, WKP);
 80a05d8:	f000 fe96 	bl	80a1308 <_Z19__fetch_global_Wirev>
 80a05dc:	4c15      	ldr	r4, [pc, #84]	; (80a0634 <_GLOBAL__sub_I_accelPin+0xe8>)
 80a05de:	4601      	mov	r1, r0
 80a05e0:	462a      	mov	r2, r5
 80a05e2:	2311      	movs	r3, #17
 80a05e4:	4620      	mov	r0, r4
 80a05e6:	f7ff fe7b 	bl	80a02e0 <_ZN9LIS3DHI2CC1ER7TwoWirehi>
 80a05ea:	4620      	mov	r0, r4
 80a05ec:	4912      	ldr	r1, [pc, #72]	; (80a0638 <_GLOBAL__sub_I_accelPin+0xec>)
 80a05ee:	4632      	mov	r2, r6
 80a05f0:	f000 ff70 	bl	80a14d4 <__aeabi_atexit>

void loop()
{
  runDiagnostic();
 
}
 80a05f4:	b008      	add	sp, #32
 80a05f6:	bd70      	pop	{r4, r5, r6, pc}
 80a05f8:	20000349 	.word	0x20000349
 80a05fc:	2000034b 	.word	0x2000034b
 80a0600:	20000330 	.word	0x20000330
 80a0604:	20000348 	.word	0x20000348
 80a0608:	20000328 	.word	0x20000328
 80a060c:	2000034a 	.word	0x2000034a
 80a0610:	2000036c 	.word	0x2000036c
 80a0614:	080a03a1 	.word	0x080a03a1
 80a0618:	2000034c 	.word	0x2000034c
 80a061c:	080a1738 	.word	0x080a1738
 80a0620:	080a0389 	.word	0x080a0389
 80a0624:	080a0385 	.word	0x080a0385
 80a0628:	080a03dd 	.word	0x080a03dd
 80a062c:	20000308 	.word	0x20000308
 80a0630:	080a0411 	.word	0x080a0411
 80a0634:	20000334 	.word	0x20000334
 80a0638:	080a00af 	.word	0x080a00af

080a063c <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a063c:	b508      	push	{r3, lr}
 80a063e:	4b02      	ldr	r3, [pc, #8]	; (80a0648 <HAL_USB_USART_Init+0xc>)
 80a0640:	681b      	ldr	r3, [r3, #0]
 80a0642:	681b      	ldr	r3, [r3, #0]
 80a0644:	9301      	str	r3, [sp, #4]
 80a0646:	bd08      	pop	{r3, pc}
 80a0648:	080601d8 	.word	0x080601d8

080a064c <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a064c:	b508      	push	{r3, lr}
 80a064e:	4b02      	ldr	r3, [pc, #8]	; (80a0658 <HAL_USB_USART_Begin+0xc>)
 80a0650:	681b      	ldr	r3, [r3, #0]
 80a0652:	685b      	ldr	r3, [r3, #4]
 80a0654:	9301      	str	r3, [sp, #4]
 80a0656:	bd08      	pop	{r3, pc}
 80a0658:	080601d8 	.word	0x080601d8

080a065c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a065c:	b508      	push	{r3, lr}
 80a065e:	4b02      	ldr	r3, [pc, #8]	; (80a0668 <HAL_USB_USART_Available_Data+0xc>)
 80a0660:	681b      	ldr	r3, [r3, #0]
 80a0662:	691b      	ldr	r3, [r3, #16]
 80a0664:	9301      	str	r3, [sp, #4]
 80a0666:	bd08      	pop	{r3, pc}
 80a0668:	080601d8 	.word	0x080601d8

080a066c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a066c:	b508      	push	{r3, lr}
 80a066e:	4b02      	ldr	r3, [pc, #8]	; (80a0678 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a0670:	681b      	ldr	r3, [r3, #0]
 80a0672:	695b      	ldr	r3, [r3, #20]
 80a0674:	9301      	str	r3, [sp, #4]
 80a0676:	bd08      	pop	{r3, pc}
 80a0678:	080601d8 	.word	0x080601d8

080a067c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a067c:	b508      	push	{r3, lr}
 80a067e:	4b02      	ldr	r3, [pc, #8]	; (80a0688 <HAL_USB_USART_Receive_Data+0xc>)
 80a0680:	681b      	ldr	r3, [r3, #0]
 80a0682:	699b      	ldr	r3, [r3, #24]
 80a0684:	9301      	str	r3, [sp, #4]
 80a0686:	bd08      	pop	{r3, pc}
 80a0688:	080601d8 	.word	0x080601d8

080a068c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a068c:	b508      	push	{r3, lr}
 80a068e:	4b02      	ldr	r3, [pc, #8]	; (80a0698 <HAL_USB_USART_Send_Data+0xc>)
 80a0690:	681b      	ldr	r3, [r3, #0]
 80a0692:	69db      	ldr	r3, [r3, #28]
 80a0694:	9301      	str	r3, [sp, #4]
 80a0696:	bd08      	pop	{r3, pc}
 80a0698:	080601d8 	.word	0x080601d8

080a069c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a069c:	b508      	push	{r3, lr}
 80a069e:	4b02      	ldr	r3, [pc, #8]	; (80a06a8 <HAL_USB_USART_Flush_Data+0xc>)
 80a06a0:	681b      	ldr	r3, [r3, #0]
 80a06a2:	6a1b      	ldr	r3, [r3, #32]
 80a06a4:	9301      	str	r3, [sp, #4]
 80a06a6:	bd08      	pop	{r3, pc}
 80a06a8:	080601d8 	.word	0x080601d8

080a06ac <HAL_I2C_Request_Data>:
DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
 80a06ac:	b508      	push	{r3, lr}
 80a06ae:	4b02      	ldr	r3, [pc, #8]	; (80a06b8 <HAL_I2C_Request_Data+0xc>)
 80a06b0:	681b      	ldr	r3, [r3, #0]
 80a06b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a06b4:	9301      	str	r3, [sp, #4]
 80a06b6:	bd08      	pop	{r3, pc}
 80a06b8:	080601ac 	.word	0x080601ac

080a06bc <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
 80a06bc:	b508      	push	{r3, lr}
 80a06be:	4b02      	ldr	r3, [pc, #8]	; (80a06c8 <HAL_I2C_Begin_Transmission+0xc>)
 80a06c0:	681b      	ldr	r3, [r3, #0]
 80a06c2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a06c4:	9301      	str	r3, [sp, #4]
 80a06c6:	bd08      	pop	{r3, pc}
 80a06c8:	080601ac 	.word	0x080601ac

080a06cc <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
 80a06cc:	b508      	push	{r3, lr}
 80a06ce:	4b02      	ldr	r3, [pc, #8]	; (80a06d8 <HAL_I2C_End_Transmission+0xc>)
 80a06d0:	681b      	ldr	r3, [r3, #0]
 80a06d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a06d4:	9301      	str	r3, [sp, #4]
 80a06d6:	bd08      	pop	{r3, pc}
 80a06d8:	080601ac 	.word	0x080601ac

080a06dc <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a06dc:	b508      	push	{r3, lr}
 80a06de:	4b02      	ldr	r3, [pc, #8]	; (80a06e8 <HAL_I2C_Write_Data+0xc>)
 80a06e0:	681b      	ldr	r3, [r3, #0]
 80a06e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a06e4:	9301      	str	r3, [sp, #4]
 80a06e6:	bd08      	pop	{r3, pc}
 80a06e8:	080601ac 	.word	0x080601ac

080a06ec <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a06ec:	b508      	push	{r3, lr}
 80a06ee:	4b02      	ldr	r3, [pc, #8]	; (80a06f8 <HAL_I2C_Available_Data+0xc>)
 80a06f0:	681b      	ldr	r3, [r3, #0]
 80a06f2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a06f4:	9301      	str	r3, [sp, #4]
 80a06f6:	bd08      	pop	{r3, pc}
 80a06f8:	080601ac 	.word	0x080601ac

080a06fc <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a06fc:	b508      	push	{r3, lr}
 80a06fe:	4b02      	ldr	r3, [pc, #8]	; (80a0708 <HAL_I2C_Read_Data+0xc>)
 80a0700:	681b      	ldr	r3, [r3, #0]
 80a0702:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a0704:	9301      	str	r3, [sp, #4]
 80a0706:	bd08      	pop	{r3, pc}
 80a0708:	080601ac 	.word	0x080601ac

080a070c <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a070c:	b508      	push	{r3, lr}
 80a070e:	4b02      	ldr	r3, [pc, #8]	; (80a0718 <HAL_I2C_Peek_Data+0xc>)
 80a0710:	681b      	ldr	r3, [r3, #0]
 80a0712:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0714:	9301      	str	r3, [sp, #4]
 80a0716:	bd08      	pop	{r3, pc}
 80a0718:	080601ac 	.word	0x080601ac

080a071c <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a071c:	b508      	push	{r3, lr}
 80a071e:	4b02      	ldr	r3, [pc, #8]	; (80a0728 <HAL_I2C_Flush_Data+0xc>)
 80a0720:	681b      	ldr	r3, [r3, #0]
 80a0722:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a0724:	9301      	str	r3, [sp, #4]
 80a0726:	bd08      	pop	{r3, pc}
 80a0728:	080601ac 	.word	0x080601ac

080a072c <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a072c:	b508      	push	{r3, lr}
 80a072e:	4b02      	ldr	r3, [pc, #8]	; (80a0738 <HAL_I2C_Is_Enabled+0xc>)
 80a0730:	681b      	ldr	r3, [r3, #0]
 80a0732:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a0734:	9301      	str	r3, [sp, #4]
 80a0736:	bd08      	pop	{r3, pc}
 80a0738:	080601ac 	.word	0x080601ac

080a073c <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a073c:	b508      	push	{r3, lr}
 80a073e:	4b03      	ldr	r3, [pc, #12]	; (80a074c <HAL_I2C_Init+0x10>)
 80a0740:	681b      	ldr	r3, [r3, #0]
 80a0742:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a0746:	9301      	str	r3, [sp, #4]
 80a0748:	bd08      	pop	{r3, pc}
 80a074a:	0000      	.short	0x0000
 80a074c:	080601ac 	.word	0x080601ac

080a0750 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a0750:	b508      	push	{r3, lr}
 80a0752:	4b02      	ldr	r3, [pc, #8]	; (80a075c <HAL_USART_Init+0xc>)
 80a0754:	681b      	ldr	r3, [r3, #0]
 80a0756:	699b      	ldr	r3, [r3, #24]
 80a0758:	9301      	str	r3, [sp, #4]
 80a075a:	bd08      	pop	{r3, pc}
 80a075c:	080601c4 	.word	0x080601c4

080a0760 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0760:	b508      	push	{r3, lr}
 80a0762:	4b02      	ldr	r3, [pc, #8]	; (80a076c <HAL_USART_Write_Data+0xc>)
 80a0764:	681b      	ldr	r3, [r3, #0]
 80a0766:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0768:	9301      	str	r3, [sp, #4]
 80a076a:	bd08      	pop	{r3, pc}
 80a076c:	080601c4 	.word	0x080601c4

080a0770 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0770:	b508      	push	{r3, lr}
 80a0772:	4b02      	ldr	r3, [pc, #8]	; (80a077c <HAL_USART_Available_Data+0xc>)
 80a0774:	681b      	ldr	r3, [r3, #0]
 80a0776:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0778:	9301      	str	r3, [sp, #4]
 80a077a:	bd08      	pop	{r3, pc}
 80a077c:	080601c4 	.word	0x080601c4

080a0780 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a0780:	b508      	push	{r3, lr}
 80a0782:	4b02      	ldr	r3, [pc, #8]	; (80a078c <HAL_USART_Read_Data+0xc>)
 80a0784:	681b      	ldr	r3, [r3, #0]
 80a0786:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0788:	9301      	str	r3, [sp, #4]
 80a078a:	bd08      	pop	{r3, pc}
 80a078c:	080601c4 	.word	0x080601c4

080a0790 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a0790:	b508      	push	{r3, lr}
 80a0792:	4b02      	ldr	r3, [pc, #8]	; (80a079c <HAL_USART_Peek_Data+0xc>)
 80a0794:	681b      	ldr	r3, [r3, #0]
 80a0796:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0798:	9301      	str	r3, [sp, #4]
 80a079a:	bd08      	pop	{r3, pc}
 80a079c:	080601c4 	.word	0x080601c4

080a07a0 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a07a0:	b508      	push	{r3, lr}
 80a07a2:	4b02      	ldr	r3, [pc, #8]	; (80a07ac <HAL_USART_Flush_Data+0xc>)
 80a07a4:	681b      	ldr	r3, [r3, #0]
 80a07a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a07a8:	9301      	str	r3, [sp, #4]
 80a07aa:	bd08      	pop	{r3, pc}
 80a07ac:	080601c4 	.word	0x080601c4

080a07b0 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a07b0:	b508      	push	{r3, lr}
 80a07b2:	4b02      	ldr	r3, [pc, #8]	; (80a07bc <HAL_USART_Is_Enabled+0xc>)
 80a07b4:	681b      	ldr	r3, [r3, #0]
 80a07b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a07b8:	9301      	str	r3, [sp, #4]
 80a07ba:	bd08      	pop	{r3, pc}
 80a07bc:	080601c4 	.word	0x080601c4

080a07c0 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a07c0:	b508      	push	{r3, lr}
 80a07c2:	4b02      	ldr	r3, [pc, #8]	; (80a07cc <HAL_USART_Available_Data_For_Write+0xc>)
 80a07c4:	681b      	ldr	r3, [r3, #0]
 80a07c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a07c8:	9301      	str	r3, [sp, #4]
 80a07ca:	bd08      	pop	{r3, pc}
 80a07cc:	080601c4 	.word	0x080601c4

080a07d0 <os_timer_create>:
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
DYNALIB_FN(6, hal_concurrent, os_thread_delay_until, os_result_t(system_tick_t*, system_tick_t))
DYNALIB_FN(7, hal_concurrent, os_thread_scheduling, void(bool, void*))

DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
 80a07d0:	b508      	push	{r3, lr}
 80a07d2:	4b02      	ldr	r3, [pc, #8]	; (80a07dc <os_timer_create+0xc>)
 80a07d4:	681b      	ldr	r3, [r3, #0]
 80a07d6:	6a1b      	ldr	r3, [r3, #32]
 80a07d8:	9301      	str	r3, [sp, #4]
 80a07da:	bd08      	pop	{r3, pc}
 80a07dc:	080601d0 	.word	0x080601d0

080a07e0 <os_timer_destroy>:
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
 80a07e0:	b508      	push	{r3, lr}
 80a07e2:	4b02      	ldr	r3, [pc, #8]	; (80a07ec <os_timer_destroy+0xc>)
 80a07e4:	681b      	ldr	r3, [r3, #0]
 80a07e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a07e8:	9301      	str	r3, [sp, #4]
 80a07ea:	bd08      	pop	{r3, pc}
 80a07ec:	080601d0 	.word	0x080601d0

080a07f0 <os_timer_get_id>:
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
 80a07f0:	b508      	push	{r3, lr}
 80a07f2:	4b02      	ldr	r3, [pc, #8]	; (80a07fc <os_timer_get_id+0xc>)
 80a07f4:	681b      	ldr	r3, [r3, #0]
 80a07f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a07f8:	9301      	str	r3, [sp, #4]
 80a07fa:	bd08      	pop	{r3, pc}
 80a07fc:	080601d0 	.word	0x080601d0

080a0800 <os_timer_change>:
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))
 80a0800:	b508      	push	{r3, lr}
 80a0802:	4b02      	ldr	r3, [pc, #8]	; (80a080c <os_timer_change+0xc>)
 80a0804:	681b      	ldr	r3, [r3, #0]
 80a0806:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0808:	9301      	str	r3, [sp, #4]
 80a080a:	bd08      	pop	{r3, pc}
 80a080c:	080601d0 	.word	0x080601d0

080a0810 <os_mutex_create>:

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a0810:	b508      	push	{r3, lr}
 80a0812:	4b02      	ldr	r3, [pc, #8]	; (80a081c <os_mutex_create+0xc>)
 80a0814:	681b      	ldr	r3, [r3, #0]
 80a0816:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0818:	9301      	str	r3, [sp, #4]
 80a081a:	bd08      	pop	{r3, pc}
 80a081c:	080601d0 	.word	0x080601d0

080a0820 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a0820:	b508      	push	{r3, lr}
 80a0822:	4b02      	ldr	r3, [pc, #8]	; (80a082c <HAL_RNG_GetRandomNumber+0xc>)
 80a0824:	681b      	ldr	r3, [r3, #0]
 80a0826:	685b      	ldr	r3, [r3, #4]
 80a0828:	9301      	str	r3, [sp, #4]
 80a082a:	bd08      	pop	{r3, pc}
 80a082c:	0806019c 	.word	0x0806019c

080a0830 <HAL_Timer_Get_Milli_Seconds>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a0830:	b508      	push	{r3, lr}
 80a0832:	4b02      	ldr	r3, [pc, #8]	; (80a083c <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a0834:	681b      	ldr	r3, [r3, #0]
 80a0836:	695b      	ldr	r3, [r3, #20]
 80a0838:	9301      	str	r3, [sp, #4]
 80a083a:	bd08      	pop	{r3, pc}
 80a083c:	0806019c 	.word	0x0806019c

080a0840 <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a0840:	b508      	push	{r3, lr}
 80a0842:	4b02      	ldr	r3, [pc, #8]	; (80a084c <HAL_SPI_Init+0xc>)
 80a0844:	681b      	ldr	r3, [r3, #0]
 80a0846:	69db      	ldr	r3, [r3, #28]
 80a0848:	9301      	str	r3, [sp, #4]
 80a084a:	bd08      	pop	{r3, pc}
 80a084c:	080601b4 	.word	0x080601b4

080a0850 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a0850:	b508      	push	{r3, lr}
 80a0852:	4b02      	ldr	r3, [pc, #8]	; (80a085c <HAL_SPI_Is_Enabled+0xc>)
 80a0854:	681b      	ldr	r3, [r3, #0]
 80a0856:	6a1b      	ldr	r3, [r3, #32]
 80a0858:	9301      	str	r3, [sp, #4]
 80a085a:	bd08      	pop	{r3, pc}
 80a085c:	080601b4 	.word	0x080601b4

080a0860 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a0860:	b508      	push	{r3, lr}
 80a0862:	4b02      	ldr	r3, [pc, #8]	; (80a086c <HAL_Pin_Map+0xc>)
 80a0864:	681b      	ldr	r3, [r3, #0]
 80a0866:	681b      	ldr	r3, [r3, #0]
 80a0868:	9301      	str	r3, [sp, #4]
 80a086a:	bd08      	pop	{r3, pc}
 80a086c:	080601b0 	.word	0x080601b0

080a0870 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a0870:	b508      	push	{r3, lr}
 80a0872:	4b02      	ldr	r3, [pc, #8]	; (80a087c <HAL_Pin_Mode+0xc>)
 80a0874:	681b      	ldr	r3, [r3, #0]
 80a0876:	689b      	ldr	r3, [r3, #8]
 80a0878:	9301      	str	r3, [sp, #4]
 80a087a:	bd08      	pop	{r3, pc}
 80a087c:	080601b0 	.word	0x080601b0

080a0880 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a0880:	b508      	push	{r3, lr}
 80a0882:	4b02      	ldr	r3, [pc, #8]	; (80a088c <network_ready+0xc>)
 80a0884:	681b      	ldr	r3, [r3, #0]
 80a0886:	691b      	ldr	r3, [r3, #16]
 80a0888:	9301      	str	r3, [sp, #4]
 80a088a:	bd08      	pop	{r3, pc}
 80a088c:	080601c8 	.word	0x080601c8

080a0890 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a0890:	b508      	push	{r3, lr}
 80a0892:	4b02      	ldr	r3, [pc, #8]	; (80a089c <set_system_mode+0xc>)
 80a0894:	681b      	ldr	r3, [r3, #0]
 80a0896:	685b      	ldr	r3, [r3, #4]
 80a0898:	9301      	str	r3, [sp, #4]
 80a089a:	bd08      	pop	{r3, pc}
 80a089c:	080601a4 	.word	0x080601a4

080a08a0 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a08a0:	b508      	push	{r3, lr}
 80a08a2:	4b02      	ldr	r3, [pc, #8]	; (80a08ac <system_delay_ms+0xc>)
 80a08a4:	681b      	ldr	r3, [r3, #0]
 80a08a6:	695b      	ldr	r3, [r3, #20]
 80a08a8:	9301      	str	r3, [sp, #4]
 80a08aa:	bd08      	pop	{r3, pc}
 80a08ac:	080601a4 	.word	0x080601a4

080a08b0 <system_set_usb_request_app_handler>:
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
DYNALIB_FN(23, system, system_notify_time_changed, void(uint32_t, void*, void*))
DYNALIB_FN(24, system, main_thread_current, uint8_t(void*))

#ifdef USB_VENDOR_REQUEST_ENABLE
DYNALIB_FN(25, system, system_set_usb_request_app_handler, void(usb_request_app_handler_type, void*))
 80a08b0:	b508      	push	{r3, lr}
 80a08b2:	4b02      	ldr	r3, [pc, #8]	; (80a08bc <system_set_usb_request_app_handler+0xc>)
 80a08b4:	681b      	ldr	r3, [r3, #0]
 80a08b6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a08b8:	9301      	str	r3, [sp, #4]
 80a08ba:	bd08      	pop	{r3, pc}
 80a08bc:	080601a4 	.word	0x080601a4

080a08c0 <system_set_usb_request_result>:
DYNALIB_FN(26, system, system_set_usb_request_result, void(USBRequest*, int, void*))
 80a08c0:	b508      	push	{r3, lr}
 80a08c2:	4b02      	ldr	r3, [pc, #8]	; (80a08cc <system_set_usb_request_result+0xc>)
 80a08c4:	681b      	ldr	r3, [r3, #0]
 80a08c6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a08c8:	9301      	str	r3, [sp, #4]
 80a08ca:	bd08      	pop	{r3, pc}
 80a08cc:	080601a4 	.word	0x080601a4

080a08d0 <free>:
#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
DYNALIB_FN(1, rt, free, void(void*))
 80a08d0:	b508      	push	{r3, lr}
 80a08d2:	4b02      	ldr	r3, [pc, #8]	; (80a08dc <free+0xc>)
 80a08d4:	681b      	ldr	r3, [r3, #0]
 80a08d6:	685b      	ldr	r3, [r3, #4]
 80a08d8:	9301      	str	r3, [sp, #4]
 80a08da:	bd08      	pop	{r3, pc}
 80a08dc:	080601a0 	.word	0x080601a0

080a08e0 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a08e0:	b508      	push	{r3, lr}
 80a08e2:	4b02      	ldr	r3, [pc, #8]	; (80a08ec <vsnprintf+0xc>)
 80a08e4:	681b      	ldr	r3, [r3, #0]
 80a08e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a08e8:	9301      	str	r3, [sp, #4]
 80a08ea:	bd08      	pop	{r3, pc}
 80a08ec:	080601a0 	.word	0x080601a0

080a08f0 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a08f0:	4770      	bx	lr

080a08f2 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a08f2:	2000      	movs	r0, #0
 80a08f4:	4601      	mov	r1, r0
 80a08f6:	4602      	mov	r2, r0
 80a08f8:	f7ff bfc2 	b.w	80a0880 <network_ready>

080a08fc <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a08fc:	4803      	ldr	r0, [pc, #12]	; (80a090c <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x10>)
 80a08fe:	4b04      	ldr	r3, [pc, #16]	; (80a0910 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a0900:	4904      	ldr	r1, [pc, #16]	; (80a0914 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x18>)
 80a0902:	4a05      	ldr	r2, [pc, #20]	; (80a0918 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x1c>)
 80a0904:	6003      	str	r3, [r0, #0]
 80a0906:	f000 bde5 	b.w	80a14d4 <__aeabi_atexit>
 80a090a:	bf00      	nop
 80a090c:	20000370 	.word	0x20000370
 80a0910:	080a1780 	.word	0x080a1780
 80a0914:	080a08f1 	.word	0x080a08f1
 80a0918:	20000308 	.word	0x20000308

080a091c <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a091c:	4b08      	ldr	r3, [pc, #32]	; (80a0940 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x24>)
 80a091e:	2200      	movs	r2, #0
 80a0920:	4908      	ldr	r1, [pc, #32]	; (80a0944 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x28>)
 80a0922:	701a      	strb	r2, [r3, #0]
 80a0924:	2301      	movs	r3, #1
 80a0926:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a0928:	4907      	ldr	r1, [pc, #28]	; (80a0948 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x2c>)
 80a092a:	700a      	strb	r2, [r1, #0]
 80a092c:	4a07      	ldr	r2, [pc, #28]	; (80a094c <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x30>)
 80a092e:	7013      	strb	r3, [r2, #0]
 80a0930:	4b07      	ldr	r3, [pc, #28]	; (80a0950 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x34>)
 80a0932:	2202      	movs	r2, #2
 80a0934:	701a      	strb	r2, [r3, #0]
 80a0936:	4b07      	ldr	r3, [pc, #28]	; (80a0954 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x38>)
 80a0938:	2208      	movs	r2, #8
 80a093a:	701a      	strb	r2, [r3, #0]
 80a093c:	4770      	bx	lr
 80a093e:	bf00      	nop
 80a0940:	20000378 	.word	0x20000378
 80a0944:	20000379 	.word	0x20000379
 80a0948:	20000376 	.word	0x20000376
 80a094c:	20000377 	.word	0x20000377
 80a0950:	20000375 	.word	0x20000375
 80a0954:	20000374 	.word	0x20000374

080a0958 <_GLOBAL__sub_I__ZN8USBMouseC2Ev>:
 80a0958:	4b08      	ldr	r3, [pc, #32]	; (80a097c <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x24>)
 80a095a:	2200      	movs	r2, #0
 80a095c:	4908      	ldr	r1, [pc, #32]	; (80a0980 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x28>)
 80a095e:	701a      	strb	r2, [r3, #0]
 80a0960:	2301      	movs	r3, #1
 80a0962:	700b      	strb	r3, [r1, #0]
 80a0964:	4907      	ldr	r1, [pc, #28]	; (80a0984 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x2c>)
 80a0966:	700a      	strb	r2, [r1, #0]
 80a0968:	4a07      	ldr	r2, [pc, #28]	; (80a0988 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x30>)
 80a096a:	7013      	strb	r3, [r2, #0]
 80a096c:	4b07      	ldr	r3, [pc, #28]	; (80a098c <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x34>)
 80a096e:	2202      	movs	r2, #2
 80a0970:	701a      	strb	r2, [r3, #0]
 80a0972:	4b07      	ldr	r3, [pc, #28]	; (80a0990 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x38>)
 80a0974:	2208      	movs	r2, #8
 80a0976:	701a      	strb	r2, [r3, #0]
 80a0978:	4770      	bx	lr
 80a097a:	bf00      	nop
 80a097c:	2000037e 	.word	0x2000037e
 80a0980:	2000037f 	.word	0x2000037f
 80a0984:	2000037b 	.word	0x2000037b
 80a0988:	2000037d 	.word	0x2000037d
 80a098c:	2000037a 	.word	0x2000037a
 80a0990:	2000037c 	.word	0x2000037c

080a0994 <_GLOBAL__sub_I__ZN9TCPServerC2Etm>:
 80a0994:	4b08      	ldr	r3, [pc, #32]	; (80a09b8 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x24>)
 80a0996:	2200      	movs	r2, #0
 80a0998:	4908      	ldr	r1, [pc, #32]	; (80a09bc <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x28>)
 80a099a:	701a      	strb	r2, [r3, #0]
 80a099c:	2301      	movs	r3, #1
 80a099e:	700b      	strb	r3, [r1, #0]
 80a09a0:	4907      	ldr	r1, [pc, #28]	; (80a09c0 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x2c>)
 80a09a2:	700a      	strb	r2, [r1, #0]
 80a09a4:	4a07      	ldr	r2, [pc, #28]	; (80a09c4 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x30>)
 80a09a6:	7013      	strb	r3, [r2, #0]
 80a09a8:	4b07      	ldr	r3, [pc, #28]	; (80a09c8 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x34>)
 80a09aa:	2202      	movs	r2, #2
 80a09ac:	701a      	strb	r2, [r3, #0]
 80a09ae:	4b07      	ldr	r3, [pc, #28]	; (80a09cc <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x38>)
 80a09b0:	2208      	movs	r2, #8
 80a09b2:	701a      	strb	r2, [r3, #0]
 80a09b4:	4770      	bx	lr
 80a09b6:	bf00      	nop
 80a09b8:	20000384 	.word	0x20000384
 80a09bc:	20000385 	.word	0x20000385
 80a09c0:	20000382 	.word	0x20000382
 80a09c4:	20000383 	.word	0x20000383
 80a09c8:	20000381 	.word	0x20000381
 80a09cc:	20000380 	.word	0x20000380

080a09d0 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a09d0:	4770      	bx	lr

080a09d2 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a09d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a09d4:	4606      	mov	r6, r0
 80a09d6:	4615      	mov	r5, r2
 80a09d8:	460c      	mov	r4, r1
 80a09da:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a09dc:	42bc      	cmp	r4, r7
 80a09de:	d006      	beq.n	80a09ee <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a09e0:	6833      	ldr	r3, [r6, #0]
 80a09e2:	4630      	mov	r0, r6
 80a09e4:	689b      	ldr	r3, [r3, #8]
 80a09e6:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a09ea:	4798      	blx	r3
 80a09ec:	e7f6      	b.n	80a09dc <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a09ee:	4628      	mov	r0, r5
 80a09f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a09f2 <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a09f2:	7c00      	ldrb	r0, [r0, #16]
 80a09f4:	2200      	movs	r2, #0
 80a09f6:	f7ff be71 	b.w	80a06dc <HAL_I2C_Write_Data>

080a09fa <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a09fa:	7c00      	ldrb	r0, [r0, #16]
 80a09fc:	2100      	movs	r1, #0
 80a09fe:	f7ff be75 	b.w	80a06ec <HAL_I2C_Available_Data>

080a0a02 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a0a02:	7c00      	ldrb	r0, [r0, #16]
 80a0a04:	2100      	movs	r1, #0
 80a0a06:	f7ff be79 	b.w	80a06fc <HAL_I2C_Read_Data>

080a0a0a <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0a0a:	7c00      	ldrb	r0, [r0, #16]
 80a0a0c:	2100      	movs	r1, #0
 80a0a0e:	f7ff be7d 	b.w	80a070c <HAL_I2C_Peek_Data>

080a0a12 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a0a12:	7c00      	ldrb	r0, [r0, #16]
 80a0a14:	2100      	movs	r1, #0
 80a0a16:	f7ff be81 	b.w	80a071c <HAL_I2C_Flush_Data>

080a0a1a <_ZN7TwoWireD0Ev>:
 80a0a1a:	b510      	push	{r4, lr}
 80a0a1c:	4604      	mov	r4, r0
 80a0a1e:	f7ff fb3c 	bl	80a009a <_ZdlPv>
 80a0a22:	4620      	mov	r0, r4
 80a0a24:	bd10      	pop	{r4, pc}
	...

080a0a28 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0a28:	b510      	push	{r4, lr}
 80a0a2a:	4604      	mov	r4, r0
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0a2c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a0a30:	6082      	str	r2, [r0, #8]
 80a0a32:	4a05      	ldr	r2, [pc, #20]	; (80a0a48 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0a34:	2300      	movs	r3, #0
 80a0a36:	6043      	str	r3, [r0, #4]
 80a0a38:	6002      	str	r2, [r0, #0]
{
  _i2c = i2c;
 80a0a3a:	7401      	strb	r1, [r0, #16]
  HAL_I2C_Init(_i2c, NULL);
 80a0a3c:	4608      	mov	r0, r1
 80a0a3e:	4619      	mov	r1, r3
 80a0a40:	f7ff fe7c 	bl	80a073c <HAL_I2C_Init>

}
 80a0a44:	4620      	mov	r0, r4
 80a0a46:	bd10      	pop	{r4, pc}
 80a0a48:	080a1790 	.word	0x080a1790

080a0a4c <_ZN7TwoWire11requestFromEhhh>:
{
	HAL_I2C_End(_i2c, NULL);
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)
{
 80a0a4c:	b513      	push	{r0, r1, r4, lr}
  uint8_t result = HAL_I2C_Request_Data(_i2c, address, quantity, sendStop, NULL);
 80a0a4e:	2400      	movs	r4, #0
 80a0a50:	7c00      	ldrb	r0, [r0, #16]
 80a0a52:	9400      	str	r4, [sp, #0]
 80a0a54:	f7ff fe2a 	bl	80a06ac <HAL_I2C_Request_Data>
  return result;
}
 80a0a58:	b2c0      	uxtb	r0, r0
 80a0a5a:	b002      	add	sp, #8
 80a0a5c:	bd10      	pop	{r4, pc}

080a0a5e <_ZN7TwoWire11requestFromEii>:
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}

uint8_t TwoWire::requestFrom(int address, int quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
 80a0a5e:	b2c9      	uxtb	r1, r1
 80a0a60:	b2d2      	uxtb	r2, r2
 80a0a62:	2301      	movs	r3, #1
 80a0a64:	f7ff bff2 	b.w	80a0a4c <_ZN7TwoWire11requestFromEhhh>

080a0a68 <_ZN7TwoWire17beginTransmissionEh>:
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
 80a0a68:	7c00      	ldrb	r0, [r0, #16]
 80a0a6a:	2200      	movs	r2, #0
 80a0a6c:	f7ff be26 	b.w	80a06bc <HAL_I2C_Begin_Transmission>

080a0a70 <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
 80a0a70:	7c00      	ldrb	r0, [r0, #16]
 80a0a72:	2200      	movs	r2, #0
 80a0a74:	f7ff be2a 	b.w	80a06cc <HAL_I2C_End_Transmission>

080a0a78 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
 80a0a78:	2101      	movs	r1, #1
 80a0a7a:	f7ff bff9 	b.w	80a0a70 <_ZN7TwoWire15endTransmissionEh>

080a0a7e <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a0a7e:	7c00      	ldrb	r0, [r0, #16]
 80a0a80:	2100      	movs	r1, #0
 80a0a82:	f7ff be53 	b.w	80a072c <HAL_I2C_Is_Enabled>

080a0a86 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a0a86:	4770      	bx	lr

080a0a88 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0a88:	7441      	strb	r1, [r0, #17]
 80a0a8a:	4770      	bx	lr

080a0a8c <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a0a8c:	7c00      	ldrb	r0, [r0, #16]
 80a0a8e:	f7ff be97 	b.w	80a07c0 <HAL_USART_Available_Data_For_Write>

080a0a92 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a0a92:	7c00      	ldrb	r0, [r0, #16]
 80a0a94:	f7ff be6c 	b.w	80a0770 <HAL_USART_Available_Data>

080a0a98 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a0a98:	7c00      	ldrb	r0, [r0, #16]
 80a0a9a:	f7ff be79 	b.w	80a0790 <HAL_USART_Peek_Data>

080a0a9e <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a0a9e:	7c00      	ldrb	r0, [r0, #16]
 80a0aa0:	f7ff be6e 	b.w	80a0780 <HAL_USART_Read_Data>

080a0aa4 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a0aa4:	7c00      	ldrb	r0, [r0, #16]
 80a0aa6:	f7ff be7b 	b.w	80a07a0 <HAL_USART_Flush_Data>

080a0aaa <_ZN11USARTSerialD0Ev>:
 80a0aaa:	b510      	push	{r4, lr}
 80a0aac:	4604      	mov	r4, r0
 80a0aae:	f7ff faf4 	bl	80a009a <_ZdlPv>
 80a0ab2:	4620      	mov	r0, r4
 80a0ab4:	bd10      	pop	{r4, pc}

080a0ab6 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a0ab6:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0ab8:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a0aba:	4604      	mov	r4, r0
 80a0abc:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0abe:	b925      	cbnz	r5, 80a0aca <_ZN11USARTSerial5writeEh+0x14>
 80a0ac0:	7c00      	ldrb	r0, [r0, #16]
 80a0ac2:	f7ff fe7d 	bl	80a07c0 <HAL_USART_Available_Data_For_Write>
 80a0ac6:	2800      	cmp	r0, #0
 80a0ac8:	dd05      	ble.n	80a0ad6 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0aca:	7c20      	ldrb	r0, [r4, #16]
 80a0acc:	4631      	mov	r1, r6
  }
  return 0;
}
 80a0ace:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0ad2:	f7ff be45 	b.w	80a0760 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a0ad6:	4628      	mov	r0, r5
 80a0ad8:	bd70      	pop	{r4, r5, r6, pc}
	...

080a0adc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0adc:	b510      	push	{r4, lr}
 80a0ade:	4604      	mov	r4, r0
 80a0ae0:	2000      	movs	r0, #0
 80a0ae2:	6060      	str	r0, [r4, #4]
 80a0ae4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0ae8:	60a0      	str	r0, [r4, #8]
 80a0aea:	4806      	ldr	r0, [pc, #24]	; (80a0b04 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a0aec:	7421      	strb	r1, [r4, #16]
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0aee:	6020      	str	r0, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a0af0:	2001      	movs	r0, #1
 80a0af2:	7460      	strb	r0, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a0af4:	4608      	mov	r0, r1
 80a0af6:	4611      	mov	r1, r2
 80a0af8:	461a      	mov	r2, r3
 80a0afa:	f7ff fe29 	bl	80a0750 <HAL_USART_Init>
}
 80a0afe:	4620      	mov	r0, r4
 80a0b00:	bd10      	pop	{r4, pc}
 80a0b02:	bf00      	nop
 80a0b04:	080a17b8 	.word	0x080a17b8

080a0b08 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a0b08:	7c00      	ldrb	r0, [r0, #16]
 80a0b0a:	f7ff be51 	b.w	80a07b0 <HAL_USART_Is_Enabled>
	...

080a0b10 <_Z22__fetch_global_Serial1v>:
// Preinstantiate Objects //////////////////////////////////////////////////////
static Ring_Buffer serial1_rx_buffer;
static Ring_Buffer serial1_tx_buffer;

USARTSerial& __fetch_global_Serial1()
{
 80a0b10:	b538      	push	{r3, r4, r5, lr}
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a0b12:	4d0c      	ldr	r5, [pc, #48]	; (80a0b44 <_Z22__fetch_global_Serial1v+0x34>)
 80a0b14:	6829      	ldr	r1, [r5, #0]
 80a0b16:	f011 0401 	ands.w	r4, r1, #1
 80a0b1a:	d111      	bne.n	80a0b40 <_Z22__fetch_global_Serial1v+0x30>
 80a0b1c:	4628      	mov	r0, r5
 80a0b1e:	f7ff fabe 	bl	80a009e <__cxa_guard_acquire>
 80a0b22:	b168      	cbz	r0, 80a0b40 <_Z22__fetch_global_Serial1v+0x30>
 80a0b24:	4621      	mov	r1, r4
 80a0b26:	4a08      	ldr	r2, [pc, #32]	; (80a0b48 <_Z22__fetch_global_Serial1v+0x38>)
 80a0b28:	4b08      	ldr	r3, [pc, #32]	; (80a0b4c <_Z22__fetch_global_Serial1v+0x3c>)
 80a0b2a:	4809      	ldr	r0, [pc, #36]	; (80a0b50 <_Z22__fetch_global_Serial1v+0x40>)
 80a0b2c:	f7ff ffd6 	bl	80a0adc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a0b30:	4628      	mov	r0, r5
 80a0b32:	f7ff fab9 	bl	80a00a8 <__cxa_guard_release>
 80a0b36:	4806      	ldr	r0, [pc, #24]	; (80a0b50 <_Z22__fetch_global_Serial1v+0x40>)
 80a0b38:	4906      	ldr	r1, [pc, #24]	; (80a0b54 <_Z22__fetch_global_Serial1v+0x44>)
 80a0b3a:	4a07      	ldr	r2, [pc, #28]	; (80a0b58 <_Z22__fetch_global_Serial1v+0x48>)
 80a0b3c:	f000 fcca 	bl	80a14d4 <__aeabi_atexit>
	return serial1;
}
 80a0b40:	4803      	ldr	r0, [pc, #12]	; (80a0b50 <_Z22__fetch_global_Serial1v+0x40>)
 80a0b42:	bd38      	pop	{r3, r4, r5, pc}
 80a0b44:	20000420 	.word	0x20000420
 80a0b48:	20000424 	.word	0x20000424
 80a0b4c:	2000039c 	.word	0x2000039c
 80a0b50:	20000388 	.word	0x20000388
 80a0b54:	080a0a87 	.word	0x080a0a87
 80a0b58:	20000308 	.word	0x20000308

080a0b5c <_GLOBAL__sub_I_tone>:
 80a0b5c:	4b08      	ldr	r3, [pc, #32]	; (80a0b80 <_GLOBAL__sub_I_tone+0x24>)
 80a0b5e:	2200      	movs	r2, #0
 80a0b60:	4908      	ldr	r1, [pc, #32]	; (80a0b84 <_GLOBAL__sub_I_tone+0x28>)
 80a0b62:	701a      	strb	r2, [r3, #0]
 80a0b64:	2301      	movs	r3, #1
 80a0b66:	700b      	strb	r3, [r1, #0]
 80a0b68:	4907      	ldr	r1, [pc, #28]	; (80a0b88 <_GLOBAL__sub_I_tone+0x2c>)
 80a0b6a:	700a      	strb	r2, [r1, #0]
 80a0b6c:	4a07      	ldr	r2, [pc, #28]	; (80a0b8c <_GLOBAL__sub_I_tone+0x30>)
 80a0b6e:	7013      	strb	r3, [r2, #0]
 80a0b70:	4b07      	ldr	r3, [pc, #28]	; (80a0b90 <_GLOBAL__sub_I_tone+0x34>)
 80a0b72:	2202      	movs	r2, #2
 80a0b74:	701a      	strb	r2, [r3, #0]
 80a0b76:	4b07      	ldr	r3, [pc, #28]	; (80a0b94 <_GLOBAL__sub_I_tone+0x38>)
 80a0b78:	2208      	movs	r2, #8
 80a0b7a:	701a      	strb	r2, [r3, #0]
 80a0b7c:	4770      	bx	lr
 80a0b7e:	bf00      	nop
 80a0b80:	200004ac 	.word	0x200004ac
 80a0b84:	200004ad 	.word	0x200004ad
 80a0b88:	200004aa 	.word	0x200004aa
 80a0b8c:	200004ab 	.word	0x200004ab
 80a0b90:	200004a9 	.word	0x200004a9
 80a0b94:	200004a8 	.word	0x200004a8

080a0b98 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0b98:	7441      	strb	r1, [r0, #17]
 80a0b9a:	4770      	bx	lr

080a0b9c <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a0b9c:	4770      	bx	lr

080a0b9e <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a0b9e:	7c00      	ldrb	r0, [r0, #16]
 80a0ba0:	2100      	movs	r1, #0
 80a0ba2:	f7ff bd6b 	b.w	80a067c <HAL_USB_USART_Receive_Data>

080a0ba6 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a0ba6:	7c00      	ldrb	r0, [r0, #16]
 80a0ba8:	2101      	movs	r1, #1
 80a0baa:	f7ff bd67 	b.w	80a067c <HAL_USB_USART_Receive_Data>

080a0bae <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a0bae:	7c00      	ldrb	r0, [r0, #16]
 80a0bb0:	f7ff bd5c 	b.w	80a066c <HAL_USB_USART_Available_Data_For_Write>

080a0bb4 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a0bb4:	7c00      	ldrb	r0, [r0, #16]
 80a0bb6:	f7ff bd51 	b.w	80a065c <HAL_USB_USART_Available_Data>

080a0bba <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a0bba:	b538      	push	{r3, r4, r5, lr}
 80a0bbc:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a0bbe:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a0bc0:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a0bc2:	f7ff fd53 	bl	80a066c <HAL_USB_USART_Available_Data_For_Write>
 80a0bc6:	2800      	cmp	r0, #0
 80a0bc8:	dc01      	bgt.n	80a0bce <_ZN9USBSerial5writeEh+0x14>
 80a0bca:	7c60      	ldrb	r0, [r4, #17]
 80a0bcc:	b120      	cbz	r0, 80a0bd8 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a0bce:	7c20      	ldrb	r0, [r4, #16]
 80a0bd0:	4629      	mov	r1, r5
 80a0bd2:	f7ff fd5b 	bl	80a068c <HAL_USB_USART_Send_Data>
    return 1;
 80a0bd6:	2001      	movs	r0, #1
  }
  return 0;
}
 80a0bd8:	bd38      	pop	{r3, r4, r5, pc}

080a0bda <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a0bda:	7c00      	ldrb	r0, [r0, #16]
 80a0bdc:	f7ff bd5e 	b.w	80a069c <HAL_USB_USART_Flush_Data>

080a0be0 <_ZN9USBSerialD0Ev>:
 80a0be0:	b510      	push	{r4, lr}
 80a0be2:	4604      	mov	r4, r0
 80a0be4:	f7ff fa59 	bl	80a009a <_ZdlPv>
 80a0be8:	4620      	mov	r0, r4
 80a0bea:	bd10      	pop	{r4, pc}

080a0bec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a0bec:	b510      	push	{r4, lr}
 80a0bee:	4604      	mov	r4, r0
 80a0bf0:	2300      	movs	r3, #0
 80a0bf2:	6043      	str	r3, [r0, #4]
 80a0bf4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a0bf8:	6083      	str	r3, [r0, #8]
 80a0bfa:	4b05      	ldr	r3, [pc, #20]	; (80a0c10 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
{
  _serial = serial;
 80a0bfc:	7401      	strb	r1, [r0, #16]

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a0bfe:	6003      	str	r3, [r0, #0]
{
  _serial = serial;
  _blocking = true;
 80a0c00:	2301      	movs	r3, #1
 80a0c02:	7443      	strb	r3, [r0, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a0c04:	4608      	mov	r0, r1
 80a0c06:	4611      	mov	r1, r2
 80a0c08:	f7ff fd18 	bl	80a063c <HAL_USB_USART_Init>
}
 80a0c0c:	4620      	mov	r0, r4
 80a0c0e:	bd10      	pop	{r4, pc}
 80a0c10:	080a17e8 	.word	0x080a17e8

080a0c14 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a0c14:	7c00      	ldrb	r0, [r0, #16]
 80a0c16:	2200      	movs	r2, #0
 80a0c18:	f7ff bd18 	b.w	80a064c <HAL_USB_USART_Begin>

080a0c1c <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a0c1c:	b510      	push	{r4, lr}
 80a0c1e:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a0c20:	2100      	movs	r1, #0
 80a0c22:	2214      	movs	r2, #20
 80a0c24:	f000 fd39 	bl	80a169a <memset>

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a0c28:	4b05      	ldr	r3, [pc, #20]	; (80a0c40 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a0c2a:	4620      	mov	r0, r4

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a0c2c:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a0c2e:	4b05      	ldr	r3, [pc, #20]	; (80a0c44 <_Z19acquireSerialBufferv+0x28>)
 80a0c30:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a0c32:	f240 1301 	movw	r3, #257	; 0x101
 80a0c36:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a0c38:	2381      	movs	r3, #129	; 0x81
 80a0c3a:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a0c3c:	bd10      	pop	{r4, pc}
 80a0c3e:	bf00      	nop
 80a0c40:	20000535 	.word	0x20000535
 80a0c44:	200004b4 	.word	0x200004b4

080a0c48 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a0c48:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a0c4a:	4d0e      	ldr	r5, [pc, #56]	; (80a0c84 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a0c4c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a0c4e:	a801      	add	r0, sp, #4
 80a0c50:	f7ff ffe4 	bl	80a0c1c <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a0c54:	6829      	ldr	r1, [r5, #0]
 80a0c56:	f011 0401 	ands.w	r4, r1, #1
 80a0c5a:	d110      	bne.n	80a0c7e <_Z16_fetch_usbserialv+0x36>
 80a0c5c:	4628      	mov	r0, r5
 80a0c5e:	f7ff fa1e 	bl	80a009e <__cxa_guard_acquire>
 80a0c62:	b160      	cbz	r0, 80a0c7e <_Z16_fetch_usbserialv+0x36>
 80a0c64:	4621      	mov	r1, r4
 80a0c66:	aa01      	add	r2, sp, #4
 80a0c68:	4807      	ldr	r0, [pc, #28]	; (80a0c88 <_Z16_fetch_usbserialv+0x40>)
 80a0c6a:	f7ff ffbf 	bl	80a0bec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a0c6e:	4628      	mov	r0, r5
 80a0c70:	f7ff fa1a 	bl	80a00a8 <__cxa_guard_release>
 80a0c74:	4804      	ldr	r0, [pc, #16]	; (80a0c88 <_Z16_fetch_usbserialv+0x40>)
 80a0c76:	4905      	ldr	r1, [pc, #20]	; (80a0c8c <_Z16_fetch_usbserialv+0x44>)
 80a0c78:	4a05      	ldr	r2, [pc, #20]	; (80a0c90 <_Z16_fetch_usbserialv+0x48>)
 80a0c7a:	f000 fc2b 	bl	80a14d4 <__aeabi_atexit>
	return _usbserial;
}
 80a0c7e:	4802      	ldr	r0, [pc, #8]	; (80a0c88 <_Z16_fetch_usbserialv+0x40>)
 80a0c80:	b007      	add	sp, #28
 80a0c82:	bd30      	pop	{r4, r5, pc}
 80a0c84:	200004b0 	.word	0x200004b0
 80a0c88:	20000638 	.word	0x20000638
 80a0c8c:	080a0b9d 	.word	0x080a0b9d
 80a0c90:	20000308 	.word	0x20000308

080a0c94 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a0c94:	b510      	push	{r4, lr}
 80a0c96:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a0c98:	2100      	movs	r1, #0
 80a0c9a:	2214      	movs	r2, #20
 80a0c9c:	f000 fcfd 	bl	80a169a <memset>

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a0ca0:	4b05      	ldr	r3, [pc, #20]	; (80a0cb8 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a0ca2:	4620      	mov	r0, r4

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a0ca4:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a0ca6:	4b05      	ldr	r3, [pc, #20]	; (80a0cbc <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a0ca8:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a0caa:	f240 1301 	movw	r3, #257	; 0x101
 80a0cae:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a0cb0:	2381      	movs	r3, #129	; 0x81
 80a0cb2:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a0cb4:	bd10      	pop	{r4, pc}
 80a0cb6:	bf00      	nop
 80a0cb8:	200006e8 	.word	0x200006e8
 80a0cbc:	20000650 	.word	0x20000650

080a0cc0 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a0cc0:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a0cc2:	4c0e      	ldr	r4, [pc, #56]	; (80a0cfc <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a0cc4:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a0cc6:	a801      	add	r0, sp, #4
 80a0cc8:	f7ff ffe4 	bl	80a0c94 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a0ccc:	6823      	ldr	r3, [r4, #0]
 80a0cce:	07db      	lsls	r3, r3, #31
 80a0cd0:	d410      	bmi.n	80a0cf4 <_Z17_fetch_usbserial1v+0x34>
 80a0cd2:	4620      	mov	r0, r4
 80a0cd4:	f7ff f9e3 	bl	80a009e <__cxa_guard_acquire>
 80a0cd8:	b160      	cbz	r0, 80a0cf4 <_Z17_fetch_usbserial1v+0x34>
 80a0cda:	2101      	movs	r1, #1
 80a0cdc:	aa01      	add	r2, sp, #4
 80a0cde:	4808      	ldr	r0, [pc, #32]	; (80a0d00 <_Z17_fetch_usbserial1v+0x40>)
 80a0ce0:	f7ff ff84 	bl	80a0bec <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a0ce4:	4620      	mov	r0, r4
 80a0ce6:	f7ff f9df 	bl	80a00a8 <__cxa_guard_release>
 80a0cea:	4805      	ldr	r0, [pc, #20]	; (80a0d00 <_Z17_fetch_usbserial1v+0x40>)
 80a0cec:	4905      	ldr	r1, [pc, #20]	; (80a0d04 <_Z17_fetch_usbserial1v+0x44>)
 80a0cee:	4a06      	ldr	r2, [pc, #24]	; (80a0d08 <_Z17_fetch_usbserial1v+0x48>)
 80a0cf0:	f000 fbf0 	bl	80a14d4 <__aeabi_atexit>
  return _usbserial1;
}
 80a0cf4:	4802      	ldr	r0, [pc, #8]	; (80a0d00 <_Z17_fetch_usbserial1v+0x40>)
 80a0cf6:	b006      	add	sp, #24
 80a0cf8:	bd10      	pop	{r4, pc}
 80a0cfa:	bf00      	nop
 80a0cfc:	2000064c 	.word	0x2000064c
 80a0d00:	200006d4 	.word	0x200006d4
 80a0d04:	080a0b9d 	.word	0x080a0b9d
 80a0d08:	20000308 	.word	0x20000308

080a0d0c <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a0d0c:	4770      	bx	lr

080a0d0e <_ZN9IPAddressD0Ev>:
 80a0d0e:	b510      	push	{r4, lr}
 80a0d10:	4604      	mov	r4, r0
 80a0d12:	f7ff f9c2 	bl	80a009a <_ZdlPv>
 80a0d16:	4620      	mov	r0, r4
 80a0d18:	bd10      	pop	{r4, pc}

080a0d1a <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a0d1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0d1c:	460f      	mov	r7, r1
 80a0d1e:	f100 0608 	add.w	r6, r0, #8
 80a0d22:	1d05      	adds	r5, r0, #4
 80a0d24:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0d26:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a0d2a:	4638      	mov	r0, r7
 80a0d2c:	220a      	movs	r2, #10
 80a0d2e:	f000 fa16 	bl	80a115e <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0d32:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0d34:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0d36:	d007      	beq.n	80a0d48 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a0d38:	2c00      	cmp	r4, #0
 80a0d3a:	d0f4      	beq.n	80a0d26 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0d3c:	4638      	mov	r0, r7
 80a0d3e:	212e      	movs	r1, #46	; 0x2e
 80a0d40:	f000 f9c8 	bl	80a10d4 <_ZN5Print5printEc>
 80a0d44:	4404      	add	r4, r0
 80a0d46:	e7ee      	b.n	80a0d26 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a0d48:	4620      	mov	r0, r4
 80a0d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0d4c <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a0d4c:	b510      	push	{r4, lr}
 80a0d4e:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a0d52:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a0d56:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a0d5a:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a0d5e:	2304      	movs	r3, #4
 80a0d60:	6041      	str	r1, [r0, #4]
 80a0d62:	7503      	strb	r3, [r0, #20]
 80a0d64:	bd10      	pop	{r4, pc}
	...

080a0d68 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a0d68:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0d6a:	4604      	mov	r4, r0
 80a0d6c:	4d04      	ldr	r5, [pc, #16]	; (80a0d80 <_ZN9IPAddressC1Ehhhh+0x18>)
 80a0d6e:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a0d70:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a0d74:	9500      	str	r5, [sp, #0]
 80a0d76:	f7ff ffe9 	bl	80a0d4c <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a0d7a:	4620      	mov	r0, r4
 80a0d7c:	b003      	add	sp, #12
 80a0d7e:	bd30      	pop	{r4, r5, pc}
 80a0d80:	080a1818 	.word	0x080a1818

080a0d84 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
 80a0d84:	4b08      	ldr	r3, [pc, #32]	; (80a0da8 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x24>)
 80a0d86:	2200      	movs	r2, #0
 80a0d88:	4908      	ldr	r1, [pc, #32]	; (80a0dac <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x28>)
 80a0d8a:	701a      	strb	r2, [r3, #0]
 80a0d8c:	2301      	movs	r3, #1
 80a0d8e:	700b      	strb	r3, [r1, #0]
 80a0d90:	4907      	ldr	r1, [pc, #28]	; (80a0db0 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x2c>)
 80a0d92:	700a      	strb	r2, [r1, #0]
 80a0d94:	4a07      	ldr	r2, [pc, #28]	; (80a0db4 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x30>)
 80a0d96:	7013      	strb	r3, [r2, #0]
 80a0d98:	4b07      	ldr	r3, [pc, #28]	; (80a0db8 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x34>)
 80a0d9a:	2202      	movs	r2, #2
 80a0d9c:	701a      	strb	r2, [r3, #0]
 80a0d9e:	4b07      	ldr	r3, [pc, #28]	; (80a0dbc <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x38>)
 80a0da0:	2208      	movs	r2, #8
 80a0da2:	701a      	strb	r2, [r3, #0]
 80a0da4:	4770      	bx	lr
 80a0da6:	bf00      	nop
 80a0da8:	200007ed 	.word	0x200007ed
 80a0dac:	200007ee 	.word	0x200007ee
 80a0db0:	200007eb 	.word	0x200007eb
 80a0db4:	200007ec 	.word	0x200007ec
 80a0db8:	200007ea 	.word	0x200007ea
 80a0dbc:	200007e9 	.word	0x200007e9

080a0dc0 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a0dc0:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a0dc2:	4b14      	ldr	r3, [pc, #80]	; (80a0e14 <serialEventRun+0x54>)
 80a0dc4:	b133      	cbz	r3, 80a0dd4 <serialEventRun+0x14>
 80a0dc6:	f7ff ff3f 	bl	80a0c48 <_Z16_fetch_usbserialv>
 80a0dca:	6803      	ldr	r3, [r0, #0]
 80a0dcc:	691b      	ldr	r3, [r3, #16]
 80a0dce:	4798      	blx	r3
 80a0dd0:	2800      	cmp	r0, #0
 80a0dd2:	dc16      	bgt.n	80a0e02 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a0dd4:	4b10      	ldr	r3, [pc, #64]	; (80a0e18 <serialEventRun+0x58>)
 80a0dd6:	b133      	cbz	r3, 80a0de6 <serialEventRun+0x26>
 80a0dd8:	f7ff fe9a 	bl	80a0b10 <_Z22__fetch_global_Serial1v>
 80a0ddc:	6803      	ldr	r3, [r0, #0]
 80a0dde:	691b      	ldr	r3, [r3, #16]
 80a0de0:	4798      	blx	r3
 80a0de2:	2800      	cmp	r0, #0
 80a0de4:	dc10      	bgt.n	80a0e08 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a0de6:	4b0d      	ldr	r3, [pc, #52]	; (80a0e1c <serialEventRun+0x5c>)
 80a0de8:	b10b      	cbz	r3, 80a0dee <serialEventRun+0x2e>
 80a0dea:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a0dee:	4b0c      	ldr	r3, [pc, #48]	; (80a0e20 <serialEventRun+0x60>)
 80a0df0:	b17b      	cbz	r3, 80a0e12 <serialEventRun+0x52>
 80a0df2:	f7ff ff65 	bl	80a0cc0 <_Z17_fetch_usbserial1v>
 80a0df6:	6803      	ldr	r3, [r0, #0]
 80a0df8:	691b      	ldr	r3, [r3, #16]
 80a0dfa:	4798      	blx	r3
 80a0dfc:	2800      	cmp	r0, #0
 80a0dfe:	dc06      	bgt.n	80a0e0e <serialEventRun+0x4e>
 80a0e00:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a0e02:	f3af 8000 	nop.w
 80a0e06:	e7e5      	b.n	80a0dd4 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a0e08:	f3af 8000 	nop.w
 80a0e0c:	e7eb      	b.n	80a0de6 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a0e0e:	f3af 8000 	nop.w
 80a0e12:	bd08      	pop	{r3, pc}
	...

080a0e24 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a0e24:	b508      	push	{r3, lr}
	serialEventRun();
 80a0e26:	f7ff ffcb 	bl	80a0dc0 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a0e2a:	f7ff fd01 	bl	80a0830 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a0e2e:	4b01      	ldr	r3, [pc, #4]	; (80a0e34 <_post_loop+0x10>)
 80a0e30:	6018      	str	r0, [r3, #0]
 80a0e32:	bd08      	pop	{r3, pc}
 80a0e34:	20000874 	.word	0x20000874

080a0e38 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a0e38:	4802      	ldr	r0, [pc, #8]	; (80a0e44 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a0e3a:	4a03      	ldr	r2, [pc, #12]	; (80a0e48 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a0e3c:	4903      	ldr	r1, [pc, #12]	; (80a0e4c <_Z33system_initialize_user_backup_ramv+0x14>)
 80a0e3e:	1a12      	subs	r2, r2, r0
 80a0e40:	f000 bc20 	b.w	80a1684 <memcpy>
 80a0e44:	40024000 	.word	0x40024000
 80a0e48:	40024004 	.word	0x40024004
 80a0e4c:	080a19b0 	.word	0x080a19b0

080a0e50 <_Z26usb_request_custom_handlerPcjjPj>:
#ifdef USB_VENDOR_REQUEST_ENABLE

// Synchronous handler for customizable requests (USBRequestType::USB_REQUEST_CUSTOM)
bool __attribute((weak)) usb_request_custom_handler(char* buf, size_t buf_size, size_t req_size, size_t* rep_size) {
    return false;
}
 80a0e50:	2000      	movs	r0, #0
 80a0e52:	4770      	bx	lr

080a0e54 <_Z23usb_request_app_handlerP10USBRequestPv>:

bool usb_request_app_handler(USBRequest* req, void* reserved) {
 80a0e54:	b537      	push	{r0, r1, r2, r4, r5, lr}
    switch (req->type) {
 80a0e56:	6843      	ldr	r3, [r0, #4]
// Synchronous handler for customizable requests (USBRequestType::USB_REQUEST_CUSTOM)
bool __attribute((weak)) usb_request_custom_handler(char* buf, size_t buf_size, size_t req_size, size_t* rep_size) {
    return false;
}

bool usb_request_app_handler(USBRequest* req, void* reserved) {
 80a0e58:	4604      	mov	r4, r0
    switch (req->type) {
 80a0e5a:	2b0a      	cmp	r3, #10
 80a0e5c:	d00f      	beq.n	80a0e7e <_Z23usb_request_app_handlerP10USBRequestPv+0x2a>
 80a0e5e:	2b50      	cmp	r3, #80	; 0x50
 80a0e60:	d11d      	bne.n	80a0e9e <_Z23usb_request_app_handlerP10USBRequestPv+0x4a>
#if Wiring_LogConfig
    case USB_REQUEST_LOG_CONFIG: {
        if (!log_process_config_request_callback || !log_process_config_request_callback(req->data, USB_REQUEST_BUFFER_SIZE,
 80a0e62:	4b10      	ldr	r3, [pc, #64]	; (80a0ea4 <_Z23usb_request_app_handlerP10USBRequestPv+0x50>)
 80a0e64:	681d      	ldr	r5, [r3, #0]
 80a0e66:	b1d5      	cbz	r5, 80a0e9e <_Z23usb_request_app_handlerP10USBRequestPv+0x4a>
                req->request_size, &req->reply_size, (DataFormat)req->format)) {
 80a0e68:	7d03      	ldrb	r3, [r0, #20]
 80a0e6a:	f44f 7100 	mov.w	r1, #512	; 0x200
 80a0e6e:	9300      	str	r3, [sp, #0]
 80a0e70:	6880      	ldr	r0, [r0, #8]
 80a0e72:	68e2      	ldr	r2, [r4, #12]
 80a0e74:	f104 0310 	add.w	r3, r4, #16
 80a0e78:	47a8      	blx	r5

bool usb_request_app_handler(USBRequest* req, void* reserved) {
    switch (req->type) {
#if Wiring_LogConfig
    case USB_REQUEST_LOG_CONFIG: {
        if (!log_process_config_request_callback || !log_process_config_request_callback(req->data, USB_REQUEST_BUFFER_SIZE,
 80a0e7a:	b948      	cbnz	r0, 80a0e90 <_Z23usb_request_app_handlerP10USBRequestPv+0x3c>
 80a0e7c:	e00f      	b.n	80a0e9e <_Z23usb_request_app_handlerP10USBRequestPv+0x4a>
        system_set_usb_request_result(req, USB_REQUEST_RESULT_OK, nullptr);
        return true;
    }
#endif
    case USB_REQUEST_CUSTOM: {
        if (!usb_request_custom_handler(req->data, USB_REQUEST_BUFFER_SIZE, req->request_size, &req->reply_size)) {
 80a0e7e:	6880      	ldr	r0, [r0, #8]
 80a0e80:	f44f 7100 	mov.w	r1, #512	; 0x200
 80a0e84:	68e2      	ldr	r2, [r4, #12]
 80a0e86:	f104 0310 	add.w	r3, r4, #16
 80a0e8a:	f7ff ffe1 	bl	80a0e50 <_Z26usb_request_custom_handlerPcjjPj>
 80a0e8e:	b138      	cbz	r0, 80a0ea0 <_Z23usb_request_app_handlerP10USBRequestPv+0x4c>
            return false;
        }
        system_set_usb_request_result(req, USB_REQUEST_RESULT_OK, nullptr);
 80a0e90:	2100      	movs	r1, #0
 80a0e92:	4620      	mov	r0, r4
 80a0e94:	460a      	mov	r2, r1
 80a0e96:	f7ff fd13 	bl	80a08c0 <system_set_usb_request_result>
        return true;
 80a0e9a:	2001      	movs	r0, #1
 80a0e9c:	e000      	b.n	80a0ea0 <_Z23usb_request_app_handlerP10USBRequestPv+0x4c>
    switch (req->type) {
#if Wiring_LogConfig
    case USB_REQUEST_LOG_CONFIG: {
        if (!log_process_config_request_callback || !log_process_config_request_callback(req->data, USB_REQUEST_BUFFER_SIZE,
                req->request_size, &req->reply_size, (DataFormat)req->format)) {
            return false;
 80a0e9e:	2000      	movs	r0, #0
        return true;
    }
    default:
        return false; // Unsupported request type
    }
}
 80a0ea0:	b003      	add	sp, #12
 80a0ea2:	bd30      	pop	{r4, r5, pc}
 80a0ea4:	200007f0 	.word	0x200007f0

080a0ea8 <module_user_init_hook>:

#endif // USB_VENDOR_REQUEST_ENABLE

void module_user_init_hook()
{
 80a0ea8:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a0eaa:	4c0c      	ldr	r4, [pc, #48]	; (80a0edc <module_user_init_hook+0x34>)
 80a0eac:	4d0c      	ldr	r5, [pc, #48]	; (80a0ee0 <module_user_init_hook+0x38>)
 80a0eae:	6823      	ldr	r3, [r4, #0]
 80a0eb0:	1b5a      	subs	r2, r3, r5
 80a0eb2:	4253      	negs	r3, r2
 80a0eb4:	4153      	adcs	r3, r2
 80a0eb6:	4a0b      	ldr	r2, [pc, #44]	; (80a0ee4 <module_user_init_hook+0x3c>)
 80a0eb8:	7013      	strb	r3, [r2, #0]
    if (!backup_ram_was_valid_) {
 80a0eba:	b913      	cbnz	r3, 80a0ec2 <module_user_init_hook+0x1a>
        system_initialize_user_backup_ram();
 80a0ebc:	f7ff ffbc 	bl	80a0e38 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a0ec0:	6025      	str	r5, [r4, #0]
    /* for dynamically linked user part, set the random seed if the user
     * app defines random_seed_from_cloud.
     */
// todo - add a RNG define for that capability
#if defined(STM32F2XX)
    if (random_seed_from_cloud) {
 80a0ec2:	4b09      	ldr	r3, [pc, #36]	; (80a0ee8 <module_user_init_hook+0x40>)
 80a0ec4:	b11b      	cbz	r3, 80a0ece <module_user_init_hook+0x26>
    		uint32_t seed = HAL_RNG_GetRandomNumber();
 80a0ec6:	f7ff fcab 	bl	80a0820 <HAL_RNG_GetRandomNumber>
    		random_seed_from_cloud(seed);
 80a0eca:	f3af 8000 	nop.w
#endif

#ifdef USB_VENDOR_REQUEST_ENABLE
    system_set_usb_request_app_handler(usb_request_app_handler, nullptr);
#endif
}
 80a0ece:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    		random_seed_from_cloud(seed);
    }
#endif

#ifdef USB_VENDOR_REQUEST_ENABLE
    system_set_usb_request_app_handler(usb_request_app_handler, nullptr);
 80a0ed2:	4806      	ldr	r0, [pc, #24]	; (80a0eec <module_user_init_hook+0x44>)
 80a0ed4:	2100      	movs	r1, #0
 80a0ed6:	f7ff bceb 	b.w	80a08b0 <system_set_usb_request_app_handler>
 80a0eda:	bf00      	nop
 80a0edc:	40024000 	.word	0x40024000
 80a0ee0:	9a271c1e 	.word	0x9a271c1e
 80a0ee4:	200007f4 	.word	0x200007f4
 80a0ee8:	00000000 	.word	0x00000000
 80a0eec:	080a0e55 	.word	0x080a0e55

080a0ef0 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev>:
 80a0ef0:	4b08      	ldr	r3, [pc, #32]	; (80a0f14 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x24>)
 80a0ef2:	2200      	movs	r2, #0
 80a0ef4:	4908      	ldr	r1, [pc, #32]	; (80a0f18 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x28>)
 80a0ef6:	701a      	strb	r2, [r3, #0]
 80a0ef8:	2301      	movs	r3, #1
 80a0efa:	700b      	strb	r3, [r1, #0]
 80a0efc:	4907      	ldr	r1, [pc, #28]	; (80a0f1c <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x2c>)
 80a0efe:	700a      	strb	r2, [r1, #0]
 80a0f00:	4a07      	ldr	r2, [pc, #28]	; (80a0f20 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x30>)
 80a0f02:	7013      	strb	r3, [r2, #0]
 80a0f04:	4b07      	ldr	r3, [pc, #28]	; (80a0f24 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x34>)
 80a0f06:	2202      	movs	r2, #2
 80a0f08:	701a      	strb	r2, [r3, #0]
 80a0f0a:	4b07      	ldr	r3, [pc, #28]	; (80a0f28 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x38>)
 80a0f0c:	2208      	movs	r2, #8
 80a0f0e:	701a      	strb	r2, [r3, #0]
 80a0f10:	4770      	bx	lr
 80a0f12:	bf00      	nop
 80a0f14:	200007f9 	.word	0x200007f9
 80a0f18:	200007fa 	.word	0x200007fa
 80a0f1c:	200007f7 	.word	0x200007f7
 80a0f20:	200007f8 	.word	0x200007f8
 80a0f24:	200007f6 	.word	0x200007f6
 80a0f28:	200007f5 	.word	0x200007f5

080a0f2c <_GLOBAL__sub_I_usb_hid_asciimap>:
 80a0f2c:	4b08      	ldr	r3, [pc, #32]	; (80a0f50 <_GLOBAL__sub_I_usb_hid_asciimap+0x24>)
 80a0f2e:	2200      	movs	r2, #0
 80a0f30:	4908      	ldr	r1, [pc, #32]	; (80a0f54 <_GLOBAL__sub_I_usb_hid_asciimap+0x28>)
 80a0f32:	701a      	strb	r2, [r3, #0]
 80a0f34:	2301      	movs	r3, #1
 80a0f36:	700b      	strb	r3, [r1, #0]
 80a0f38:	4907      	ldr	r1, [pc, #28]	; (80a0f58 <_GLOBAL__sub_I_usb_hid_asciimap+0x2c>)
 80a0f3a:	700a      	strb	r2, [r1, #0]
 80a0f3c:	4a07      	ldr	r2, [pc, #28]	; (80a0f5c <_GLOBAL__sub_I_usb_hid_asciimap+0x30>)
 80a0f3e:	7013      	strb	r3, [r2, #0]
 80a0f40:	4b07      	ldr	r3, [pc, #28]	; (80a0f60 <_GLOBAL__sub_I_usb_hid_asciimap+0x34>)
 80a0f42:	2202      	movs	r2, #2
 80a0f44:	701a      	strb	r2, [r3, #0]
 80a0f46:	4b07      	ldr	r3, [pc, #28]	; (80a0f64 <_GLOBAL__sub_I_usb_hid_asciimap+0x38>)
 80a0f48:	2208      	movs	r2, #8
 80a0f4a:	701a      	strb	r2, [r3, #0]
 80a0f4c:	4770      	bx	lr
 80a0f4e:	bf00      	nop
 80a0f50:	200007ff 	.word	0x200007ff
 80a0f54:	20000800 	.word	0x20000800
 80a0f58:	200007fd 	.word	0x200007fd
 80a0f5c:	200007fe 	.word	0x200007fe
 80a0f60:	200007fc 	.word	0x200007fc
 80a0f64:	200007fb 	.word	0x200007fb

080a0f68 <_GLOBAL__sub_I__ZN3UDPC2Ev>:
 80a0f68:	4b08      	ldr	r3, [pc, #32]	; (80a0f8c <_GLOBAL__sub_I__ZN3UDPC2Ev+0x24>)
 80a0f6a:	2200      	movs	r2, #0
 80a0f6c:	4908      	ldr	r1, [pc, #32]	; (80a0f90 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x28>)
 80a0f6e:	701a      	strb	r2, [r3, #0]
 80a0f70:	2301      	movs	r3, #1
 80a0f72:	700b      	strb	r3, [r1, #0]
 80a0f74:	4907      	ldr	r1, [pc, #28]	; (80a0f94 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x2c>)
 80a0f76:	700a      	strb	r2, [r1, #0]
 80a0f78:	4a07      	ldr	r2, [pc, #28]	; (80a0f98 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x30>)
 80a0f7a:	7013      	strb	r3, [r2, #0]
 80a0f7c:	4b07      	ldr	r3, [pc, #28]	; (80a0f9c <_GLOBAL__sub_I__ZN3UDPC2Ev+0x34>)
 80a0f7e:	2202      	movs	r2, #2
 80a0f80:	701a      	strb	r2, [r3, #0]
 80a0f82:	4b07      	ldr	r3, [pc, #28]	; (80a0fa0 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x38>)
 80a0f84:	2208      	movs	r2, #8
 80a0f86:	701a      	strb	r2, [r3, #0]
 80a0f88:	4770      	bx	lr
 80a0f8a:	bf00      	nop
 80a0f8c:	20000805 	.word	0x20000805
 80a0f90:	20000806 	.word	0x20000806
 80a0f94:	20000803 	.word	0x20000803
 80a0f98:	20000804 	.word	0x20000804
 80a0f9c:	20000802 	.word	0x20000802
 80a0fa0:	20000801 	.word	0x20000801

080a0fa4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
 80a0fa4:	4b0a      	ldr	r3, [pc, #40]	; (80a0fd0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x2c>)
 80a0fa6:	2200      	movs	r2, #0
 80a0fa8:	490a      	ldr	r1, [pc, #40]	; (80a0fd4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x30>)
 80a0faa:	701a      	strb	r2, [r3, #0]
 80a0fac:	2301      	movs	r3, #1
 80a0fae:	700b      	strb	r3, [r1, #0]
 80a0fb0:	4909      	ldr	r1, [pc, #36]	; (80a0fd8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x34>)
 80a0fb2:	700a      	strb	r2, [r1, #0]
 80a0fb4:	4a09      	ldr	r2, [pc, #36]	; (80a0fdc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x38>)
 80a0fb6:	7013      	strb	r3, [r2, #0]
 80a0fb8:	4b09      	ldr	r3, [pc, #36]	; (80a0fe0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x3c>)
 80a0fba:	2202      	movs	r2, #2
 80a0fbc:	701a      	strb	r2, [r3, #0]
 80a0fbe:	4b09      	ldr	r3, [pc, #36]	; (80a0fe4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x40>)
 80a0fc0:	2208      	movs	r2, #8
 80a0fc2:	701a      	strb	r2, [r3, #0]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a0fc4:	4b08      	ldr	r3, [pc, #32]	; (80a0fe8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x44>)
 80a0fc6:	681a      	ldr	r2, [r3, #0]
 80a0fc8:	4b08      	ldr	r3, [pc, #32]	; (80a0fec <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x48>)
 80a0fca:	601a      	str	r2, [r3, #0]
 80a0fcc:	4770      	bx	lr
 80a0fce:	bf00      	nop
 80a0fd0:	20000811 	.word	0x20000811
 80a0fd4:	20000813 	.word	0x20000813
 80a0fd8:	20000810 	.word	0x20000810
 80a0fdc:	20000807 	.word	0x20000807
 80a0fe0:	20000808 	.word	0x20000808
 80a0fe4:	20000812 	.word	0x20000812
 80a0fe8:	20000304 	.word	0x20000304
 80a0fec:	2000080c 	.word	0x2000080c

080a0ff0 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a0ff0:	4a01      	ldr	r2, [pc, #4]	; (80a0ff8 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a0ff2:	4b02      	ldr	r3, [pc, #8]	; (80a0ffc <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a0ff4:	601a      	str	r2, [r3, #0]
 80a0ff6:	4770      	bx	lr
 80a0ff8:	080a1905 	.word	0x080a1905
 80a0ffc:	20000814 	.word	0x20000814

080a1000 <_GLOBAL__sub_I__ZN6Stream9timedReadEv>:
 80a1000:	4b08      	ldr	r3, [pc, #32]	; (80a1024 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x24>)
 80a1002:	2200      	movs	r2, #0
 80a1004:	4908      	ldr	r1, [pc, #32]	; (80a1028 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x28>)
 80a1006:	701a      	strb	r2, [r3, #0]
 80a1008:	2301      	movs	r3, #1
 80a100a:	700b      	strb	r3, [r1, #0]
 80a100c:	4907      	ldr	r1, [pc, #28]	; (80a102c <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x2c>)
 80a100e:	700a      	strb	r2, [r1, #0]
 80a1010:	4a07      	ldr	r2, [pc, #28]	; (80a1030 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x30>)
 80a1012:	7013      	strb	r3, [r2, #0]
 80a1014:	4b07      	ldr	r3, [pc, #28]	; (80a1034 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x34>)
 80a1016:	2202      	movs	r2, #2
 80a1018:	701a      	strb	r2, [r3, #0]
 80a101a:	4b07      	ldr	r3, [pc, #28]	; (80a1038 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x38>)
 80a101c:	2208      	movs	r2, #8
 80a101e:	701a      	strb	r2, [r3, #0]
 80a1020:	4770      	bx	lr
 80a1022:	bf00      	nop
 80a1024:	2000081c 	.word	0x2000081c
 80a1028:	2000081d 	.word	0x2000081d
 80a102c:	2000081a 	.word	0x2000081a
 80a1030:	2000081b 	.word	0x2000081b
 80a1034:	20000819 	.word	0x20000819
 80a1038:	20000818 	.word	0x20000818

080a103c <delay>:
  return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a103c:	2100      	movs	r1, #0
 80a103e:	f7ff bc2f 	b.w	80a08a0 <system_delay_ms>
	...

080a1044 <_GLOBAL__sub_I_setADCSampleTime>:
 80a1044:	4b08      	ldr	r3, [pc, #32]	; (80a1068 <_GLOBAL__sub_I_setADCSampleTime+0x24>)
 80a1046:	2200      	movs	r2, #0
 80a1048:	4908      	ldr	r1, [pc, #32]	; (80a106c <_GLOBAL__sub_I_setADCSampleTime+0x28>)
 80a104a:	701a      	strb	r2, [r3, #0]
 80a104c:	2301      	movs	r3, #1
 80a104e:	700b      	strb	r3, [r1, #0]
 80a1050:	4907      	ldr	r1, [pc, #28]	; (80a1070 <_GLOBAL__sub_I_setADCSampleTime+0x2c>)
 80a1052:	700a      	strb	r2, [r1, #0]
 80a1054:	4a07      	ldr	r2, [pc, #28]	; (80a1074 <_GLOBAL__sub_I_setADCSampleTime+0x30>)
 80a1056:	7013      	strb	r3, [r2, #0]
 80a1058:	4b07      	ldr	r3, [pc, #28]	; (80a1078 <_GLOBAL__sub_I_setADCSampleTime+0x34>)
 80a105a:	2202      	movs	r2, #2
 80a105c:	701a      	strb	r2, [r3, #0]
 80a105e:	4b07      	ldr	r3, [pc, #28]	; (80a107c <_GLOBAL__sub_I_setADCSampleTime+0x38>)
 80a1060:	2208      	movs	r2, #8
 80a1062:	701a      	strb	r2, [r3, #0]
 80a1064:	4770      	bx	lr
 80a1066:	bf00      	nop
 80a1068:	20000822 	.word	0x20000822
 80a106c:	20000823 	.word	0x20000823
 80a1070:	20000820 	.word	0x20000820
 80a1074:	20000821 	.word	0x20000821
 80a1078:	2000081f 	.word	0x2000081f
 80a107c:	2000081e 	.word	0x2000081e

080a1080 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a1080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1082:	4606      	mov	r6, r0
 80a1084:	460d      	mov	r5, r1
 80a1086:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a1088:	2400      	movs	r4, #0
  while (size--) {
 80a108a:	42bd      	cmp	r5, r7
 80a108c:	d00c      	beq.n	80a10a8 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a108e:	6833      	ldr	r3, [r6, #0]
 80a1090:	4630      	mov	r0, r6
 80a1092:	689b      	ldr	r3, [r3, #8]
 80a1094:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a1098:	4798      	blx	r3
     if (chunk>=0)
 80a109a:	2800      	cmp	r0, #0
 80a109c:	db01      	blt.n	80a10a2 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a109e:	4404      	add	r4, r0
 80a10a0:	e7f3      	b.n	80a108a <_ZN5Print5writeEPKhj+0xa>
/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     int chunk = write(*buffer++);
 80a10a2:	2c00      	cmp	r4, #0
 80a10a4:	bf08      	it	eq
 80a10a6:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a10a8:	4620      	mov	r0, r4
 80a10aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a10ac <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a10ac:	b570      	push	{r4, r5, r6, lr}
 80a10ae:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a10b0:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a10b2:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a10b4:	b149      	cbz	r1, 80a10ca <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a10b6:	f000 faf8 	bl	80a16aa <strlen>
 80a10ba:	682b      	ldr	r3, [r5, #0]
 80a10bc:	4602      	mov	r2, r0
 80a10be:	4621      	mov	r1, r4
 80a10c0:	4628      	mov	r0, r5
    }
 80a10c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a10c6:	68db      	ldr	r3, [r3, #12]
 80a10c8:	4718      	bx	r3
    }
 80a10ca:	bd70      	pop	{r4, r5, r6, pc}

080a10cc <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
 80a10cc:	b508      	push	{r3, lr}
  return write(str);
 80a10ce:	f7ff ffed 	bl	80a10ac <_ZN5Print5writeEPKc>
}
 80a10d2:	bd08      	pop	{r3, pc}

080a10d4 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
 80a10d4:	6803      	ldr	r3, [r0, #0]
 80a10d6:	689b      	ldr	r3, [r3, #8]
 80a10d8:	4718      	bx	r3

080a10da <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a10da:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a10dc:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a10de:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a10e0:	f7ff fff8 	bl	80a10d4 <_ZN5Print5printEc>
  n += print('\n');
 80a10e4:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a10e6:	4604      	mov	r4, r0
  n += print('\n');
 80a10e8:	4628      	mov	r0, r5
 80a10ea:	f7ff fff3 	bl	80a10d4 <_ZN5Print5printEc>
  return n;
}
 80a10ee:	4420      	add	r0, r4
 80a10f0:	bd38      	pop	{r3, r4, r5, pc}

080a10f2 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a10f2:	b538      	push	{r3, r4, r5, lr}
 80a10f4:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a10f6:	f7ff ffd9 	bl	80a10ac <_ZN5Print5writeEPKc>
 80a10fa:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a10fc:	4628      	mov	r0, r5
 80a10fe:	f7ff ffec 	bl	80a10da <_ZN5Print7printlnEv>
  return n;
}
 80a1102:	4420      	add	r0, r4
 80a1104:	bd38      	pop	{r3, r4, r5, pc}

080a1106 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a1106:	2a01      	cmp	r2, #1
 80a1108:	bf98      	it	ls
 80a110a:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a110c:	b530      	push	{r4, r5, lr}
 80a110e:	460b      	mov	r3, r1
 80a1110:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a1112:	2100      	movs	r1, #0
 80a1114:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a1118:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a111c:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a1120:	fb05 3312 	mls	r3, r5, r2, r3
 80a1124:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a1126:	2b09      	cmp	r3, #9
 80a1128:	bf94      	ite	ls
 80a112a:	3330      	addls	r3, #48	; 0x30
 80a112c:	3337      	addhi	r3, #55	; 0x37
 80a112e:	b2db      	uxtb	r3, r3
 80a1130:	4621      	mov	r1, r4
 80a1132:	f804 3901 	strb.w	r3, [r4], #-1
 80a1136:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a1138:	2d00      	cmp	r5, #0
 80a113a:	d1ef      	bne.n	80a111c <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a113c:	f7ff ffb6 	bl	80a10ac <_ZN5Print5writeEPKc>
}
 80a1140:	b00b      	add	sp, #44	; 0x2c
 80a1142:	bd30      	pop	{r4, r5, pc}

080a1144 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a1144:	b510      	push	{r4, lr}
  if (base == 0) return write(n);
 80a1146:	b92a      	cbnz	r2, 80a1154 <_ZN5Print5printEmi+0x10>
  else return printNumber(n, base);
}
 80a1148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a114c:	6803      	ldr	r3, [r0, #0]
 80a114e:	b2c9      	uxtb	r1, r1
 80a1150:	689b      	ldr	r3, [r3, #8]
 80a1152:	4718      	bx	r3
  else return printNumber(n, base);
 80a1154:	b2d2      	uxtb	r2, r2
}
 80a1156:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a115a:	f7ff bfd4 	b.w	80a1106 <_ZN5Print11printNumberEmh>

080a115e <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a115e:	f7ff bff1 	b.w	80a1144 <_ZN5Print5printEmi>

080a1162 <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a1162:	b40c      	push	{r2, r3}
 80a1164:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1168:	b087      	sub	sp, #28
 80a116a:	af00      	add	r7, sp, #0
 80a116c:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a1170:	f854 9b04 	ldr.w	r9, [r4], #4
 80a1174:	4605      	mov	r5, r0
 80a1176:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a1178:	1d38      	adds	r0, r7, #4
 80a117a:	2114      	movs	r1, #20
 80a117c:	464a      	mov	r2, r9
 80a117e:	4623      	mov	r3, r4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a1180:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a1182:	f7ff fbad 	bl	80a08e0 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a1186:	2813      	cmp	r0, #19
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a1188:	4601      	mov	r1, r0
    va_end(marker);

    if (n<bufsize)
 80a118a:	d805      	bhi.n	80a1198 <_ZN5Print11printf_implEbPKcz+0x36>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a118c:	4628      	mov	r0, r5
 80a118e:	1d39      	adds	r1, r7, #4
 80a1190:	f7ff ff8c 	bl	80a10ac <_ZN5Print5writeEPKc>
 80a1194:	4604      	mov	r4, r0
 80a1196:	e013      	b.n	80a11c0 <_ZN5Print11printf_implEbPKcz+0x5e>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a1198:	f100 0308 	add.w	r3, r0, #8
 80a119c:	f023 0307 	bic.w	r3, r3, #7
 80a11a0:	46e8      	mov	r8, sp
 80a11a2:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a11a6:	4668      	mov	r0, sp
 80a11a8:	4623      	mov	r3, r4
 80a11aa:	3101      	adds	r1, #1
 80a11ac:	464a      	mov	r2, r9
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a11ae:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a11b0:	f7ff fb96 	bl	80a08e0 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a11b4:	4669      	mov	r1, sp
 80a11b6:	4628      	mov	r0, r5
 80a11b8:	f7ff ff78 	bl	80a10ac <_ZN5Print5writeEPKc>
 80a11bc:	4604      	mov	r4, r0
 80a11be:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a11c0:	b11e      	cbz	r6, 80a11ca <_ZN5Print11printf_implEbPKcz+0x68>
        n += println();
 80a11c2:	4628      	mov	r0, r5
 80a11c4:	f7ff ff89 	bl	80a10da <_ZN5Print7printlnEv>
 80a11c8:	4404      	add	r4, r0
    return n;
}
 80a11ca:	4620      	mov	r0, r4
 80a11cc:	371c      	adds	r7, #28
 80a11ce:	46bd      	mov	sp, r7
 80a11d0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a11d4:	b002      	add	sp, #8
 80a11d6:	4770      	bx	lr

080a11d8 <_GLOBAL__sub_I_System>:
 80a11d8:	4b08      	ldr	r3, [pc, #32]	; (80a11fc <_GLOBAL__sub_I_System+0x24>)
 80a11da:	2000      	movs	r0, #0
 80a11dc:	4a08      	ldr	r2, [pc, #32]	; (80a1200 <_GLOBAL__sub_I_System+0x28>)
 80a11de:	7018      	strb	r0, [r3, #0]
 80a11e0:	2301      	movs	r3, #1
 80a11e2:	7013      	strb	r3, [r2, #0]
 80a11e4:	4a07      	ldr	r2, [pc, #28]	; (80a1204 <_GLOBAL__sub_I_System+0x2c>)
 80a11e6:	7010      	strb	r0, [r2, #0]
 80a11e8:	4a07      	ldr	r2, [pc, #28]	; (80a1208 <_GLOBAL__sub_I_System+0x30>)
 80a11ea:	7013      	strb	r3, [r2, #0]
 80a11ec:	4b07      	ldr	r3, [pc, #28]	; (80a120c <_GLOBAL__sub_I_System+0x34>)
 80a11ee:	2202      	movs	r2, #2
 80a11f0:	701a      	strb	r2, [r3, #0]
 80a11f2:	4b07      	ldr	r3, [pc, #28]	; (80a1210 <_GLOBAL__sub_I_System+0x38>)
 80a11f4:	2208      	movs	r2, #8
 80a11f6:	701a      	strb	r2, [r3, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a11f8:	f7ff bb4a 	b.w	80a0890 <set_system_mode>
 80a11fc:	20000828 	.word	0x20000828
 80a1200:	20000829 	.word	0x20000829
 80a1204:	20000826 	.word	0x20000826
 80a1208:	20000827 	.word	0x20000827
 80a120c:	20000825 	.word	0x20000825
 80a1210:	20000824 	.word	0x20000824

080a1214 <_GLOBAL__sub_I__ZN5ServoC2Ev>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a1214:	4b08      	ldr	r3, [pc, #32]	; (80a1238 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x24>)
 80a1216:	2200      	movs	r2, #0
 80a1218:	4908      	ldr	r1, [pc, #32]	; (80a123c <_GLOBAL__sub_I__ZN5ServoC2Ev+0x28>)
 80a121a:	701a      	strb	r2, [r3, #0]
 80a121c:	2301      	movs	r3, #1
 80a121e:	700b      	strb	r3, [r1, #0]
 80a1220:	4907      	ldr	r1, [pc, #28]	; (80a1240 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x2c>)
 80a1222:	700a      	strb	r2, [r1, #0]
 80a1224:	4a07      	ldr	r2, [pc, #28]	; (80a1244 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x30>)
 80a1226:	7013      	strb	r3, [r2, #0]
 80a1228:	4b07      	ldr	r3, [pc, #28]	; (80a1248 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x34>)
 80a122a:	2202      	movs	r2, #2
 80a122c:	701a      	strb	r2, [r3, #0]
 80a122e:	4b07      	ldr	r3, [pc, #28]	; (80a124c <_GLOBAL__sub_I__ZN5ServoC2Ev+0x38>)
 80a1230:	2208      	movs	r2, #8
 80a1232:	701a      	strb	r2, [r3, #0]
 80a1234:	4770      	bx	lr
 80a1236:	bf00      	nop
 80a1238:	2000082e 	.word	0x2000082e
 80a123c:	2000082f 	.word	0x2000082f
 80a1240:	2000082c 	.word	0x2000082c
 80a1244:	2000082d 	.word	0x2000082d
 80a1248:	2000082b 	.word	0x2000082b
 80a124c:	2000082a 	.word	0x2000082a

080a1250 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a1250:	4770      	bx	lr

080a1252 <_ZN8SPIClassD0Ev>:
 80a1252:	b510      	push	{r4, lr}
 80a1254:	4604      	mov	r4, r0
 80a1256:	f7fe ff20 	bl	80a009a <_ZdlPv>
 80a125a:	4620      	mov	r0, r4
 80a125c:	bd10      	pop	{r4, pc}
	...

080a1260 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a1260:	b570      	push	{r4, r5, r6, lr}
 80a1262:	4604      	mov	r4, r0
 80a1264:	460e      	mov	r6, r1
 80a1266:	4b07      	ldr	r3, [pc, #28]	; (80a1284 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
	Mutex(os_mutex_t handle) : handle_(handle) {}

	/**
	 * Creates a new mutex.
	 */
	Mutex() : handle_(nullptr)
 80a1268:	2500      	movs	r5, #0
 80a126a:	6003      	str	r3, [r0, #0]
 80a126c:	f840 5f0c 	str.w	r5, [r0, #12]!
	{
		os_mutex_create(&handle_);
 80a1270:	f7ff face 	bl	80a0810 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a1274:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a1276:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a1278:	f7ff fae2 	bl	80a0840 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a127c:	60a5      	str	r5, [r4, #8]
}
 80a127e:	4620      	mov	r0, r4
 80a1280:	bd70      	pop	{r4, r5, r6, pc}
 80a1282:	bf00      	nop
 80a1284:	080a1938 	.word	0x080a1938

080a1288 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a1288:	7900      	ldrb	r0, [r0, #4]
 80a128a:	f7ff bae1 	b.w	80a0850 <HAL_SPI_Is_Enabled>
	...

080a1290 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface>:
 80a1290:	4b08      	ldr	r3, [pc, #32]	; (80a12b4 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x24>)
 80a1292:	2200      	movs	r2, #0
 80a1294:	4908      	ldr	r1, [pc, #32]	; (80a12b8 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x28>)
 80a1296:	701a      	strb	r2, [r3, #0]
 80a1298:	2301      	movs	r3, #1
 80a129a:	700b      	strb	r3, [r1, #0]
 80a129c:	4907      	ldr	r1, [pc, #28]	; (80a12bc <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x2c>)
 80a129e:	700a      	strb	r2, [r1, #0]
 80a12a0:	4a07      	ldr	r2, [pc, #28]	; (80a12c0 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x30>)
 80a12a2:	7013      	strb	r3, [r2, #0]
 80a12a4:	4b07      	ldr	r3, [pc, #28]	; (80a12c4 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x34>)
 80a12a6:	2202      	movs	r2, #2
 80a12a8:	701a      	strb	r2, [r3, #0]
 80a12aa:	4b07      	ldr	r3, [pc, #28]	; (80a12c8 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x38>)
 80a12ac:	2208      	movs	r2, #8
 80a12ae:	701a      	strb	r2, [r3, #0]
 80a12b0:	4770      	bx	lr
 80a12b2:	bf00      	nop
 80a12b4:	20000834 	.word	0x20000834
 80a12b8:	20000835 	.word	0x20000835
 80a12bc:	20000832 	.word	0x20000832
 80a12c0:	20000833 	.word	0x20000833
 80a12c4:	20000831 	.word	0x20000831
 80a12c8:	20000830 	.word	0x20000830

080a12cc <_GLOBAL__sub_I__ZN4PMICC2Ev>:
 80a12cc:	4b08      	ldr	r3, [pc, #32]	; (80a12f0 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x24>)
 80a12ce:	2200      	movs	r2, #0
 80a12d0:	4908      	ldr	r1, [pc, #32]	; (80a12f4 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x28>)
 80a12d2:	701a      	strb	r2, [r3, #0]
 80a12d4:	2301      	movs	r3, #1
 80a12d6:	700b      	strb	r3, [r1, #0]
 80a12d8:	4907      	ldr	r1, [pc, #28]	; (80a12f8 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x2c>)
 80a12da:	700a      	strb	r2, [r1, #0]
 80a12dc:	4a07      	ldr	r2, [pc, #28]	; (80a12fc <_GLOBAL__sub_I__ZN4PMICC2Ev+0x30>)
 80a12de:	7013      	strb	r3, [r2, #0]
 80a12e0:	4b07      	ldr	r3, [pc, #28]	; (80a1300 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x34>)
 80a12e2:	2202      	movs	r2, #2
 80a12e4:	701a      	strb	r2, [r3, #0]
 80a12e6:	4b07      	ldr	r3, [pc, #28]	; (80a1304 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x38>)
 80a12e8:	2208      	movs	r2, #8
 80a12ea:	701a      	strb	r2, [r3, #0]
 80a12ec:	4770      	bx	lr
 80a12ee:	bf00      	nop
 80a12f0:	2000083a 	.word	0x2000083a
 80a12f4:	2000083b 	.word	0x2000083b
 80a12f8:	20000838 	.word	0x20000838
 80a12fc:	20000839 	.word	0x20000839
 80a1300:	20000837 	.word	0x20000837
 80a1304:	20000836 	.word	0x20000836

080a1308 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a1308:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a130a:	4d0b      	ldr	r5, [pc, #44]	; (80a1338 <_Z19__fetch_global_Wirev+0x30>)
 80a130c:	6829      	ldr	r1, [r5, #0]
 80a130e:	f011 0401 	ands.w	r4, r1, #1
 80a1312:	d10f      	bne.n	80a1334 <_Z19__fetch_global_Wirev+0x2c>
 80a1314:	4628      	mov	r0, r5
 80a1316:	f7fe fec2 	bl	80a009e <__cxa_guard_acquire>
 80a131a:	b158      	cbz	r0, 80a1334 <_Z19__fetch_global_Wirev+0x2c>
 80a131c:	4621      	mov	r1, r4
 80a131e:	4807      	ldr	r0, [pc, #28]	; (80a133c <_Z19__fetch_global_Wirev+0x34>)
 80a1320:	f7ff fb82 	bl	80a0a28 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a1324:	4628      	mov	r0, r5
 80a1326:	f7fe febf 	bl	80a00a8 <__cxa_guard_release>
 80a132a:	4804      	ldr	r0, [pc, #16]	; (80a133c <_Z19__fetch_global_Wirev+0x34>)
 80a132c:	4904      	ldr	r1, [pc, #16]	; (80a1340 <_Z19__fetch_global_Wirev+0x38>)
 80a132e:	4a05      	ldr	r2, [pc, #20]	; (80a1344 <_Z19__fetch_global_Wirev+0x3c>)
 80a1330:	f000 f8d0 	bl	80a14d4 <__aeabi_atexit>
	return wire;
}
 80a1334:	4801      	ldr	r0, [pc, #4]	; (80a133c <_Z19__fetch_global_Wirev+0x34>)
 80a1336:	bd38      	pop	{r3, r4, r5, pc}
 80a1338:	2000083c 	.word	0x2000083c
 80a133c:	20000840 	.word	0x20000840
 80a1340:	080a09d1 	.word	0x080a09d1
 80a1344:	20000308 	.word	0x20000308

080a1348 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a1348:	b513      	push	{r0, r1, r4, lr}
 80a134a:	4c08      	ldr	r4, [pc, #32]	; (80a136c <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a134c:	2100      	movs	r1, #0
 80a134e:	9100      	str	r1, [sp, #0]
 80a1350:	460a      	mov	r2, r1
 80a1352:	460b      	mov	r3, r1
 80a1354:	4620      	mov	r0, r4
 80a1356:	f7ff fd07 	bl	80a0d68 <_ZN9IPAddressC1Ehhhh>
 80a135a:	4620      	mov	r0, r4
 80a135c:	4904      	ldr	r1, [pc, #16]	; (80a1370 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a135e:	4a05      	ldr	r2, [pc, #20]	; (80a1374 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a1360:	b002      	add	sp, #8
 80a1362:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1366:	f000 b8b5 	b.w	80a14d4 <__aeabi_atexit>
 80a136a:	bf00      	nop
 80a136c:	20000854 	.word	0x20000854
 80a1370:	080a0d0d 	.word	0x080a0d0d
 80a1374:	20000308 	.word	0x20000308

080a1378 <_GLOBAL__sub_I_Particle>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a1378:	4b08      	ldr	r3, [pc, #32]	; (80a139c <_GLOBAL__sub_I_Particle+0x24>)
 80a137a:	2200      	movs	r2, #0
 80a137c:	4908      	ldr	r1, [pc, #32]	; (80a13a0 <_GLOBAL__sub_I_Particle+0x28>)
 80a137e:	701a      	strb	r2, [r3, #0]
 80a1380:	2301      	movs	r3, #1
 80a1382:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a1384:	4907      	ldr	r1, [pc, #28]	; (80a13a4 <_GLOBAL__sub_I_Particle+0x2c>)
 80a1386:	700a      	strb	r2, [r1, #0]
 80a1388:	4a07      	ldr	r2, [pc, #28]	; (80a13a8 <_GLOBAL__sub_I_Particle+0x30>)
 80a138a:	7013      	strb	r3, [r2, #0]
 80a138c:	4b07      	ldr	r3, [pc, #28]	; (80a13ac <_GLOBAL__sub_I_Particle+0x34>)
 80a138e:	2202      	movs	r2, #2
 80a1390:	701a      	strb	r2, [r3, #0]
 80a1392:	4b07      	ldr	r3, [pc, #28]	; (80a13b0 <_GLOBAL__sub_I_Particle+0x38>)
 80a1394:	2208      	movs	r2, #8
 80a1396:	701a      	strb	r2, [r3, #0]
 80a1398:	4770      	bx	lr
 80a139a:	bf00      	nop
 80a139c:	20000870 	.word	0x20000870
 80a13a0:	20000871 	.word	0x20000871
 80a13a4:	2000086e 	.word	0x2000086e
 80a13a8:	2000086f 	.word	0x2000086f
 80a13ac:	2000086d 	.word	0x2000086d
 80a13b0:	2000086c 	.word	0x2000086c

080a13b4 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a13b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a13b6:	4b13      	ldr	r3, [pc, #76]	; (80a1404 <_GLOBAL__sub_I_SPI+0x50>)
 80a13b8:	2100      	movs	r1, #0
 80a13ba:	7019      	strb	r1, [r3, #0]
 80a13bc:	4b12      	ldr	r3, [pc, #72]	; (80a1408 <_GLOBAL__sub_I_SPI+0x54>)
 80a13be:	2401      	movs	r4, #1
 80a13c0:	701c      	strb	r4, [r3, #0]
 80a13c2:	4b12      	ldr	r3, [pc, #72]	; (80a140c <_GLOBAL__sub_I_SPI+0x58>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a13c4:	4f12      	ldr	r7, [pc, #72]	; (80a1410 <_GLOBAL__sub_I_SPI+0x5c>)
 80a13c6:	7019      	strb	r1, [r3, #0]
 80a13c8:	4b12      	ldr	r3, [pc, #72]	; (80a1414 <_GLOBAL__sub_I_SPI+0x60>)
 80a13ca:	2202      	movs	r2, #2
 80a13cc:	701c      	strb	r4, [r3, #0]
 80a13ce:	4b12      	ldr	r3, [pc, #72]	; (80a1418 <_GLOBAL__sub_I_SPI+0x64>)
 80a13d0:	4e12      	ldr	r6, [pc, #72]	; (80a141c <_GLOBAL__sub_I_SPI+0x68>)
 80a13d2:	701a      	strb	r2, [r3, #0]
 80a13d4:	4b12      	ldr	r3, [pc, #72]	; (80a1420 <_GLOBAL__sub_I_SPI+0x6c>)
 80a13d6:	2208      	movs	r2, #8
 80a13d8:	4d12      	ldr	r5, [pc, #72]	; (80a1424 <_GLOBAL__sub_I_SPI+0x70>)
 80a13da:	4638      	mov	r0, r7
 80a13dc:	701a      	strb	r2, [r3, #0]
 80a13de:	f7ff ff3f 	bl	80a1260 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a13e2:	4638      	mov	r0, r7

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a13e4:	4f10      	ldr	r7, [pc, #64]	; (80a1428 <_GLOBAL__sub_I_SPI+0x74>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a13e6:	462a      	mov	r2, r5
 80a13e8:	4631      	mov	r1, r6
 80a13ea:	f000 f873 	bl	80a14d4 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a13ee:	4621      	mov	r1, r4
 80a13f0:	4638      	mov	r0, r7
 80a13f2:	f7ff ff35 	bl	80a1260 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a13f6:	4638      	mov	r0, r7
 80a13f8:	4631      	mov	r1, r6
 80a13fa:	462a      	mov	r2, r5
 80a13fc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80a1400:	f000 b868 	b.w	80a14d4 <__aeabi_atexit>
 80a1404:	2000087c 	.word	0x2000087c
 80a1408:	2000087d 	.word	0x2000087d
 80a140c:	2000087a 	.word	0x2000087a
 80a1410:	20000880 	.word	0x20000880
 80a1414:	2000087b 	.word	0x2000087b
 80a1418:	20000879 	.word	0x20000879
 80a141c:	080a1251 	.word	0x080a1251
 80a1420:	20000878 	.word	0x20000878
 80a1424:	20000308 	.word	0x20000308
 80a1428:	20000890 	.word	0x20000890

080a142c <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a142c:	b510      	push	{r4, lr}
 80a142e:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a1430:	480f      	ldr	r0, [pc, #60]	; (80a1470 <pinAvailable+0x44>)
 80a1432:	f7ff ff29 	bl	80a1288 <_ZN8SPIClass9isEnabledEv>
 80a1436:	b128      	cbz	r0, 80a1444 <pinAvailable+0x18>
 80a1438:	f1a4 030d 	sub.w	r3, r4, #13
 80a143c:	2b02      	cmp	r3, #2
 80a143e:	d801      	bhi.n	80a1444 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a1440:	2000      	movs	r0, #0
 80a1442:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a1444:	f7ff ff60 	bl	80a1308 <_Z19__fetch_global_Wirev>
 80a1448:	f7ff fb19 	bl	80a0a7e <_ZN7TwoWire9isEnabledEv>
 80a144c:	b108      	cbz	r0, 80a1452 <pinAvailable+0x26>
 80a144e:	2c01      	cmp	r4, #1
 80a1450:	d9f6      	bls.n	80a1440 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a1452:	f7ff fb5d 	bl	80a0b10 <_Z22__fetch_global_Serial1v>
 80a1456:	f7ff fb57 	bl	80a0b08 <_ZN11USARTSerial9isEnabledEv>
 80a145a:	b118      	cbz	r0, 80a1464 <pinAvailable+0x38>
 80a145c:	f1a4 0312 	sub.w	r3, r4, #18
 80a1460:	2b01      	cmp	r3, #1
 80a1462:	d9ed      	bls.n	80a1440 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a1464:	2c17      	cmp	r4, #23
 80a1466:	bf8c      	ite	hi
 80a1468:	2000      	movhi	r0, #0
 80a146a:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a146c:	bd10      	pop	{r4, pc}
 80a146e:	bf00      	nop
 80a1470:	20000880 	.word	0x20000880

080a1474 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a1474:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a1476:	b538      	push	{r3, r4, r5, lr}
 80a1478:	4605      	mov	r5, r0
 80a147a:	460c      	mov	r4, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a147c:	d80a      	bhi.n	80a1494 <pinMode+0x20>
 80a147e:	29ff      	cmp	r1, #255	; 0xff
 80a1480:	d008      	beq.n	80a1494 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a1482:	f7ff ffd3 	bl	80a142c <pinAvailable>
 80a1486:	b128      	cbz	r0, 80a1494 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a1488:	4628      	mov	r0, r5
 80a148a:	4621      	mov	r1, r4
}
 80a148c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a1490:	f7ff b9ee 	b.w	80a0870 <HAL_Pin_Mode>
 80a1494:	bd38      	pop	{r3, r4, r5, pc}
	...

080a1498 <_GLOBAL__sub_I_pinMode>:
 80a1498:	4b08      	ldr	r3, [pc, #32]	; (80a14bc <_GLOBAL__sub_I_pinMode+0x24>)
 80a149a:	2200      	movs	r2, #0
 80a149c:	4908      	ldr	r1, [pc, #32]	; (80a14c0 <_GLOBAL__sub_I_pinMode+0x28>)
 80a149e:	701a      	strb	r2, [r3, #0]
 80a14a0:	2301      	movs	r3, #1
 80a14a2:	700b      	strb	r3, [r1, #0]
 80a14a4:	4907      	ldr	r1, [pc, #28]	; (80a14c4 <_GLOBAL__sub_I_pinMode+0x2c>)
 80a14a6:	700a      	strb	r2, [r1, #0]
 80a14a8:	4a07      	ldr	r2, [pc, #28]	; (80a14c8 <_GLOBAL__sub_I_pinMode+0x30>)
 80a14aa:	7013      	strb	r3, [r2, #0]
 80a14ac:	4b07      	ldr	r3, [pc, #28]	; (80a14cc <_GLOBAL__sub_I_pinMode+0x34>)
 80a14ae:	2202      	movs	r2, #2
 80a14b0:	701a      	strb	r2, [r3, #0]
 80a14b2:	4b07      	ldr	r3, [pc, #28]	; (80a14d0 <_GLOBAL__sub_I_pinMode+0x38>)
 80a14b4:	2208      	movs	r2, #8
 80a14b6:	701a      	strb	r2, [r3, #0]
 80a14b8:	4770      	bx	lr
 80a14ba:	bf00      	nop
 80a14bc:	200008a4 	.word	0x200008a4
 80a14c0:	200008a5 	.word	0x200008a5
 80a14c4:	200008a2 	.word	0x200008a2
 80a14c8:	200008a3 	.word	0x200008a3
 80a14cc:	200008a1 	.word	0x200008a1
 80a14d0:	200008a0 	.word	0x200008a0

080a14d4 <__aeabi_atexit>:
 80a14d4:	4603      	mov	r3, r0
 80a14d6:	4608      	mov	r0, r1
 80a14d8:	4619      	mov	r1, r3
 80a14da:	f000 b8c5 	b.w	80a1668 <__cxa_atexit>
	...

080a14e0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE>:
 80a14e0:	4b24      	ldr	r3, [pc, #144]	; (80a1574 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x94>)
 80a14e2:	681a      	ldr	r2, [r3, #0]
 80a14e4:	07d0      	lsls	r0, r2, #31
 80a14e6:	bf5c      	itt	pl
 80a14e8:	2201      	movpl	r2, #1
 80a14ea:	601a      	strpl	r2, [r3, #0]
 80a14ec:	4b22      	ldr	r3, [pc, #136]	; (80a1578 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x98>)
 80a14ee:	681a      	ldr	r2, [r3, #0]
 80a14f0:	07d1      	lsls	r1, r2, #31
 80a14f2:	bf5c      	itt	pl
 80a14f4:	2201      	movpl	r2, #1
 80a14f6:	601a      	strpl	r2, [r3, #0]
 80a14f8:	4b20      	ldr	r3, [pc, #128]	; (80a157c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x9c>)
 80a14fa:	681a      	ldr	r2, [r3, #0]
 80a14fc:	07d2      	lsls	r2, r2, #31
 80a14fe:	bf5c      	itt	pl
 80a1500:	2201      	movpl	r2, #1
 80a1502:	601a      	strpl	r2, [r3, #0]
 80a1504:	4b1e      	ldr	r3, [pc, #120]	; (80a1580 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa0>)
 80a1506:	681a      	ldr	r2, [r3, #0]
 80a1508:	07d0      	lsls	r0, r2, #31
 80a150a:	bf5c      	itt	pl
 80a150c:	2201      	movpl	r2, #1
 80a150e:	601a      	strpl	r2, [r3, #0]
 80a1510:	4b1c      	ldr	r3, [pc, #112]	; (80a1584 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa4>)
 80a1512:	681a      	ldr	r2, [r3, #0]
 80a1514:	07d1      	lsls	r1, r2, #31
 80a1516:	bf5c      	itt	pl
 80a1518:	2201      	movpl	r2, #1
 80a151a:	601a      	strpl	r2, [r3, #0]
 80a151c:	4b1a      	ldr	r3, [pc, #104]	; (80a1588 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa8>)
 80a151e:	681a      	ldr	r2, [r3, #0]
 80a1520:	07d2      	lsls	r2, r2, #31
 80a1522:	bf5c      	itt	pl
 80a1524:	2201      	movpl	r2, #1
 80a1526:	601a      	strpl	r2, [r3, #0]
 80a1528:	4b18      	ldr	r3, [pc, #96]	; (80a158c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xac>)
 80a152a:	681a      	ldr	r2, [r3, #0]
 80a152c:	07d0      	lsls	r0, r2, #31
 80a152e:	bf5c      	itt	pl
 80a1530:	2201      	movpl	r2, #1
 80a1532:	601a      	strpl	r2, [r3, #0]
 80a1534:	4b16      	ldr	r3, [pc, #88]	; (80a1590 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb0>)
 80a1536:	681a      	ldr	r2, [r3, #0]
 80a1538:	07d1      	lsls	r1, r2, #31
 80a153a:	bf5c      	itt	pl
 80a153c:	2201      	movpl	r2, #1
 80a153e:	601a      	strpl	r2, [r3, #0]
 80a1540:	4b14      	ldr	r3, [pc, #80]	; (80a1594 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb4>)
 80a1542:	681a      	ldr	r2, [r3, #0]
 80a1544:	07d2      	lsls	r2, r2, #31
 80a1546:	bf5c      	itt	pl
 80a1548:	2201      	movpl	r2, #1
 80a154a:	601a      	strpl	r2, [r3, #0]
 80a154c:	4b12      	ldr	r3, [pc, #72]	; (80a1598 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb8>)
 80a154e:	681a      	ldr	r2, [r3, #0]
 80a1550:	07d0      	lsls	r0, r2, #31
 80a1552:	bf5c      	itt	pl
 80a1554:	2201      	movpl	r2, #1
 80a1556:	601a      	strpl	r2, [r3, #0]
 80a1558:	4b10      	ldr	r3, [pc, #64]	; (80a159c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xbc>)
 80a155a:	681a      	ldr	r2, [r3, #0]
 80a155c:	07d1      	lsls	r1, r2, #31
 80a155e:	bf5c      	itt	pl
 80a1560:	2201      	movpl	r2, #1
 80a1562:	601a      	strpl	r2, [r3, #0]
 80a1564:	4b0e      	ldr	r3, [pc, #56]	; (80a15a0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc0>)
 80a1566:	681a      	ldr	r2, [r3, #0]
 80a1568:	07d2      	lsls	r2, r2, #31
 80a156a:	bf5c      	itt	pl
 80a156c:	2201      	movpl	r2, #1
 80a156e:	601a      	strpl	r2, [r3, #0]
 80a1570:	4770      	bx	lr
 80a1572:	bf00      	nop
 80a1574:	200008d4 	.word	0x200008d4
 80a1578:	200008d0 	.word	0x200008d0
 80a157c:	200008cc 	.word	0x200008cc
 80a1580:	200008c8 	.word	0x200008c8
 80a1584:	200008c4 	.word	0x200008c4
 80a1588:	200008c0 	.word	0x200008c0
 80a158c:	200008bc 	.word	0x200008bc
 80a1590:	200008b8 	.word	0x200008b8
 80a1594:	200008b4 	.word	0x200008b4
 80a1598:	200008b0 	.word	0x200008b0
 80a159c:	200008ac 	.word	0x200008ac
 80a15a0:	200008a8 	.word	0x200008a8

080a15a4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE>:
 80a15a4:	4b24      	ldr	r3, [pc, #144]	; (80a1638 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x94>)
 80a15a6:	681a      	ldr	r2, [r3, #0]
 80a15a8:	07d0      	lsls	r0, r2, #31
 80a15aa:	bf5c      	itt	pl
 80a15ac:	2201      	movpl	r2, #1
 80a15ae:	601a      	strpl	r2, [r3, #0]
 80a15b0:	4b22      	ldr	r3, [pc, #136]	; (80a163c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x98>)
 80a15b2:	681a      	ldr	r2, [r3, #0]
 80a15b4:	07d1      	lsls	r1, r2, #31
 80a15b6:	bf5c      	itt	pl
 80a15b8:	2201      	movpl	r2, #1
 80a15ba:	601a      	strpl	r2, [r3, #0]
 80a15bc:	4b20      	ldr	r3, [pc, #128]	; (80a1640 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x9c>)
 80a15be:	681a      	ldr	r2, [r3, #0]
 80a15c0:	07d2      	lsls	r2, r2, #31
 80a15c2:	bf5c      	itt	pl
 80a15c4:	2201      	movpl	r2, #1
 80a15c6:	601a      	strpl	r2, [r3, #0]
 80a15c8:	4b1e      	ldr	r3, [pc, #120]	; (80a1644 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa0>)
 80a15ca:	681a      	ldr	r2, [r3, #0]
 80a15cc:	07d0      	lsls	r0, r2, #31
 80a15ce:	bf5c      	itt	pl
 80a15d0:	2201      	movpl	r2, #1
 80a15d2:	601a      	strpl	r2, [r3, #0]
 80a15d4:	4b1c      	ldr	r3, [pc, #112]	; (80a1648 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa4>)
 80a15d6:	681a      	ldr	r2, [r3, #0]
 80a15d8:	07d1      	lsls	r1, r2, #31
 80a15da:	bf5c      	itt	pl
 80a15dc:	2201      	movpl	r2, #1
 80a15de:	601a      	strpl	r2, [r3, #0]
 80a15e0:	4b1a      	ldr	r3, [pc, #104]	; (80a164c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa8>)
 80a15e2:	681a      	ldr	r2, [r3, #0]
 80a15e4:	07d2      	lsls	r2, r2, #31
 80a15e6:	bf5c      	itt	pl
 80a15e8:	2201      	movpl	r2, #1
 80a15ea:	601a      	strpl	r2, [r3, #0]
 80a15ec:	4b18      	ldr	r3, [pc, #96]	; (80a1650 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xac>)
 80a15ee:	681a      	ldr	r2, [r3, #0]
 80a15f0:	07d0      	lsls	r0, r2, #31
 80a15f2:	bf5c      	itt	pl
 80a15f4:	2201      	movpl	r2, #1
 80a15f6:	601a      	strpl	r2, [r3, #0]
 80a15f8:	4b16      	ldr	r3, [pc, #88]	; (80a1654 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb0>)
 80a15fa:	681a      	ldr	r2, [r3, #0]
 80a15fc:	07d1      	lsls	r1, r2, #31
 80a15fe:	bf5c      	itt	pl
 80a1600:	2201      	movpl	r2, #1
 80a1602:	601a      	strpl	r2, [r3, #0]
 80a1604:	4b14      	ldr	r3, [pc, #80]	; (80a1658 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb4>)
 80a1606:	681a      	ldr	r2, [r3, #0]
 80a1608:	07d2      	lsls	r2, r2, #31
 80a160a:	bf5c      	itt	pl
 80a160c:	2201      	movpl	r2, #1
 80a160e:	601a      	strpl	r2, [r3, #0]
 80a1610:	4b12      	ldr	r3, [pc, #72]	; (80a165c <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb8>)
 80a1612:	681a      	ldr	r2, [r3, #0]
 80a1614:	07d0      	lsls	r0, r2, #31
 80a1616:	bf5c      	itt	pl
 80a1618:	2201      	movpl	r2, #1
 80a161a:	601a      	strpl	r2, [r3, #0]
 80a161c:	4b10      	ldr	r3, [pc, #64]	; (80a1660 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xbc>)
 80a161e:	681a      	ldr	r2, [r3, #0]
 80a1620:	07d1      	lsls	r1, r2, #31
 80a1622:	bf5c      	itt	pl
 80a1624:	2201      	movpl	r2, #1
 80a1626:	601a      	strpl	r2, [r3, #0]
 80a1628:	4b0e      	ldr	r3, [pc, #56]	; (80a1664 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc0>)
 80a162a:	681a      	ldr	r2, [r3, #0]
 80a162c:	07d2      	lsls	r2, r2, #31
 80a162e:	bf5c      	itt	pl
 80a1630:	2201      	movpl	r2, #1
 80a1632:	601a      	strpl	r2, [r3, #0]
 80a1634:	4770      	bx	lr
 80a1636:	bf00      	nop
 80a1638:	20000904 	.word	0x20000904
 80a163c:	20000900 	.word	0x20000900
 80a1640:	200008fc 	.word	0x200008fc
 80a1644:	200008f8 	.word	0x200008f8
 80a1648:	200008f4 	.word	0x200008f4
 80a164c:	200008f0 	.word	0x200008f0
 80a1650:	200008ec 	.word	0x200008ec
 80a1654:	200008e8 	.word	0x200008e8
 80a1658:	200008e4 	.word	0x200008e4
 80a165c:	200008e0 	.word	0x200008e0
 80a1660:	200008dc 	.word	0x200008dc
 80a1664:	200008d8 	.word	0x200008d8

080a1668 <__cxa_atexit>:
 80a1668:	b538      	push	{r3, r4, r5, lr}
 80a166a:	4605      	mov	r5, r0
 80a166c:	4804      	ldr	r0, [pc, #16]	; (80a1680 <__cxa_atexit+0x18>)
 80a166e:	460c      	mov	r4, r1
 80a1670:	4613      	mov	r3, r2
 80a1672:	b120      	cbz	r0, 80a167e <__cxa_atexit+0x16>
 80a1674:	2002      	movs	r0, #2
 80a1676:	4629      	mov	r1, r5
 80a1678:	4622      	mov	r2, r4
 80a167a:	f3af 8000 	nop.w
 80a167e:	bd38      	pop	{r3, r4, r5, pc}
 80a1680:	00000000 	.word	0x00000000

080a1684 <memcpy>:
 80a1684:	b510      	push	{r4, lr}
 80a1686:	1e43      	subs	r3, r0, #1
 80a1688:	440a      	add	r2, r1
 80a168a:	4291      	cmp	r1, r2
 80a168c:	d004      	beq.n	80a1698 <memcpy+0x14>
 80a168e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a1692:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a1696:	e7f8      	b.n	80a168a <memcpy+0x6>
 80a1698:	bd10      	pop	{r4, pc}

080a169a <memset>:
 80a169a:	4603      	mov	r3, r0
 80a169c:	4402      	add	r2, r0
 80a169e:	4293      	cmp	r3, r2
 80a16a0:	d002      	beq.n	80a16a8 <memset+0xe>
 80a16a2:	f803 1b01 	strb.w	r1, [r3], #1
 80a16a6:	e7fa      	b.n	80a169e <memset+0x4>
 80a16a8:	4770      	bx	lr

080a16aa <strlen>:
 80a16aa:	4603      	mov	r3, r0
 80a16ac:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a16b0:	2a00      	cmp	r2, #0
 80a16b2:	d1fb      	bne.n	80a16ac <strlen+0x2>
 80a16b4:	1a18      	subs	r0, r3, r0
 80a16b6:	3801      	subs	r0, #1
 80a16b8:	4770      	bx	lr

080a16ba <link_code_end>:
	...

080a16bc <dynalib_user>:
 80a16bc:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a16cc:	0000 0000                                   ....

080a16d0 <_ZTV9LIS3DHI2C>:
	...
 80a16d8:	00af 080a 00b1 080a 0105 080a 00bd 080a     ................
 80a16e8:	6564 6976 6563 6e20 746f 6620 756f 646e     device not found
 80a16f8:	7200 7365 7465 6974 676e 6c20 7361 4d74     .resetting lastM
 80a1708:	766f 6d65 6e65 2074 6e69 3174 735f 6372     ovement int1_src
 80a1718:	303d 2578 0078 6572 6163 696c 7262 7461     =0x%x.recalibrat
 80a1728:	6e69 0067 0000 0000                         ing.....

080a1730 <_ZTV5Timer>:
	...
 80a1738:	0411 080a 045d 080a 03c5 080a 6573 7574     ....].......setu
 80a1748:	5370 6375 6563 7373 253d 0064 6341 6563     pSuccess=%d.Acce
 80a1758:	206c 6176 756c 7365 203a 2500 2c64 6425     l values: .%d,%d
 80a1768:	252c 0064 6f6e 7320 6d61 6c70 0065 0000     ,%d.no sample...

080a1778 <_ZTVN5spark9WiFiClassE>:
	...
 80a1780:	08f3 080a 0000 0000                         ........

080a1788 <_ZTV7TwoWire>:
	...
 80a1790:	09d1 080a 0a1b 080a 09f3 080a 09d3 080a     ................
 80a17a0:	09fb 080a 0a03 080a 0a0b 080a 0a13 080a     ................

080a17b0 <_ZTV11USARTSerial>:
	...
 80a17b8:	0a87 080a 0aab 080a 0ab7 080a 1081 080a     ................
 80a17c8:	0a93 080a 0a9f 080a 0a99 080a 0aa5 080a     ................
 80a17d8:	0a89 080a 0a8d 080a                         ........

080a17e0 <_ZTV9USBSerial>:
	...
 80a17e8:	0b9d 080a 0be1 080a 0bbb 080a 1081 080a     ................
 80a17f8:	0bb5 080a 0b9f 080a 0ba7 080a 0bdb 080a     ................
 80a1808:	0baf 080a 0b99 080a                         ........

080a1810 <_ZTV9IPAddress>:
	...
 80a1818:	0d1b 080a 0d0d 080a 0d0f 080a 005a 2b25     ............Z.%+
 80a1828:	3330 3a64 3025 7532 2500 2d59 6d25 252d     03d:%02u.%Y-%m-%
 80a1838:	5464 4825 253a 3a4d 5325 7a25 6100 6373     dT%H:%M:%S%z.asc
 80a1848:	6974 656d 6600 6c00 006e 6e66 6300 646f     time.f.ln.fn.cod
 80a1858:	0065 6564 6174 6c69 0d00 000a 3025 3031     e.detail....%010
 80a1868:	2075 5d00 0020 202c 2800 3a29 0020 5b20     u .] ., .(): . [
 80a1878:	6300 646f 2065 203d 2500 0069 6564 6174     .code = .%i.deta
 80a1888:	6c69 2073 203d 6200 7561 0064 6553 6972     ils = .baud.Seri
 80a1898:	6c61 5500 4253 6553 6972 6c61 0031 7974     al.USBSerial1.ty
 80a18a8:	6570 7000 7261 6d61 6300 646d 6900 0064     pe.param.cmd.id.
 80a18b8:	6e68 0064 7473 6d72 6600 6c69 0074 766c     hnd.strm.filt.lv
 80a18c8:	006c 6461 4864 6e61 6c64 7265 7200 6d65     l.addHandler.rem
 80a18d8:	766f 4865 6e61 6c64 7265 6500 756e 486d     oveHandler.enumH
 80a18e8:	6e61 6c64 7265 0073 534a 4e4f 7453 6572     andlers.JSONStre
 80a18f8:	6d61 6f4c 4867 6e61 6c64 7265 6100 7070     amLogHandler.app
 80a1908:	6e00 6e6f 0065 7274 6361 0065 6e69 6f66     .none.trace.info
 80a1918:	7700 7261 006e 7265 6f72 0072 6170 696e     .warn.error.pani
 80a1928:	0063 6c61 006c 0000                         c.all...

080a1930 <_ZTV8SPIClass>:
	...
 80a1938:	1251 080a 1253 080a                         Q...S...

080a1940 <link_const_variable_data_end>:
 80a1940:	080a02f5 	.word	0x080a02f5
 80a1944:	080a033d 	.word	0x080a033d
 80a1948:	080a054d 	.word	0x080a054d
 80a194c:	080a08fd 	.word	0x080a08fd
 80a1950:	080a091d 	.word	0x080a091d
 80a1954:	080a0959 	.word	0x080a0959
 80a1958:	080a0995 	.word	0x080a0995
 80a195c:	080a0b5d 	.word	0x080a0b5d
 80a1960:	080a0d85 	.word	0x080a0d85
 80a1964:	080a0ef1 	.word	0x080a0ef1
 80a1968:	080a0f2d 	.word	0x080a0f2d
 80a196c:	080a0f69 	.word	0x080a0f69
 80a1970:	080a0fa5 	.word	0x080a0fa5
 80a1974:	080a0ff1 	.word	0x080a0ff1
 80a1978:	080a1001 	.word	0x080a1001
 80a197c:	080a1045 	.word	0x080a1045
 80a1980:	080a11d9 	.word	0x080a11d9
 80a1984:	080a1215 	.word	0x080a1215
 80a1988:	080a1291 	.word	0x080a1291
 80a198c:	080a12cd 	.word	0x080a12cd
 80a1990:	080a1349 	.word	0x080a1349
 80a1994:	080a1379 	.word	0x080a1379
 80a1998:	080a13b5 	.word	0x080a13b5
 80a199c:	080a1499 	.word	0x080a1499
 80a19a0:	080a14e1 	.word	0x080a14e1
 80a19a4:	080a15a5 	.word	0x080a15a5

080a19a8 <link_constructors_end>:
	...
